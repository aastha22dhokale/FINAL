
{"organisationUnits":[],"offset":0,"totalNumberOfResults":0}
2025-12-03T10:17:02.477+05:30  INFO 31436 --- [Integration-Module] [gle/netty4-1-22] c.i.d.api.service.OnePamRepository       : searchInvolvedPartyByInternalIdentifier response: Response("HTTP/1.1 Status(200)")
2025-12-03T10:17:02.479+05:30 DEBUG 31436 --- [Integration-Module] [   scheduling-1] c.i.d.c.CofaceOpsConfigReader            : Start of fetchByOrgNumber
2025-12-03T10:17:02.480+05:30 DEBUG 31436 --- [Integration-Module] [   scheduling-1] c.i.d.c.CofaceOpsConfigReader            : Fetching organisation unit config for Org Number: '9aa1ae44-f2f4-47a1-9266-f7053476a9a6'
2025-12-03T10:17:02.486+05:30 DEBUG 31436 --- [Integration-Module] [   scheduling-1] c.i.d.c.CofaceOpsConfigReader            : Fetched 0 record(s) from DD_COFACEOPS_TBL by Org Number
2025-12-03T10:17:02.486+05:30 DEBUG 31436 --- [Integration-Module] [   scheduling-1] c.i.d.c.CofaceOpsConfigReader            : End of fetchByOrgNumber
2025-12-03T10:17:02.487+05:30  INFO 31436 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : CONFIG LOADED FOR ORG=9aa1ae44-f2f4-47a1-9266-f7053476a9a6 -> {}
2025-12-03T10:17:02.487+05:30  INFO 31436 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA UUID9aa1ae44-f2f4-47a1-9266-f7053476a9a6     
2025-12-03T10:17:02.488+05:30  INFO 31436 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA UUID WRAPPERnull
2025-12-03T10:17:02.488+05:30  INFO 31436 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA ORG_NUMBER null
2025-12-03T10:17:02.489+05:30  INFO 31436 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA ORG NAMEnull
2025-12-03T10:17:02.490+05:30  INFO 31436 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA STREET NAMEnull
2025-12-03T10:17:02.490+05:30  INFO 31436 --- [Integration-Module] [   scheduling-1] c.i.d.api.repository.AccountingDAO       : AASTHA MERGE
2025-12-03T10:17:02.491+05:30  INFO 31436 --- [Integration-Module] [   scheduling-1] c.i.d.api.repository.AccountingDAO       : AASTHA MERGE2
2025-12-03T10:17:02.491+05:30  INFO 31436 --- [Integration-Module] [   scheduling-1] c.i.d.api.repository.AccountingDAO       : AASTHA MERGE7
2025-12-03T10:17:02.530+05:30 ERROR 31436 --- [Integration-Module] [   scheduling-1] c.i.d.b.tasklet.OnePamSearchApiTasklet   : Exception occurred while executing API call for UUID :9aa1ae44-f2f4-47a1-9266-f7053476a9a6 error :{}

org.springframework.dao.DataIntegrityViolationException: PreparedStatementCallback; SQL [MERGE INTO DD_ACCOUNT_TBL tgt
USING (
  SELECT ? AS DD_UUID,

         ? AS EVENT_ID,
         ? AS TYP_OF_ENTY,
         ? AS FIRST_NAME,
         ? AS ADDR_STREET_NAME,
         ? AS ADDR_HOUSE_NUMBER,
         ? AS ADDR_BOX_NUMBER,
         ? AS ADDR_POSTAL_CODE,
         ? AS ADDR_LOCALITY_NAME,
         ? AS ADDR_COUNTRY_CODE,
         ? AS ORG_NUMBER,
         ? AS DIGITAL_ADDRESS,
         ? AS UPDATED_TIME

  FROM dual
) src
ON (tgt.DD_UUID = src.DD_UUID)
WHEN MATCHED THEN UPDATE SET
  tgt.TYP_OF_ENTY        = src.TYP_OF_ENTY,
  tgt.FIRST_NAME         = src.FIRST_NAME,
  tgt.ADDR_STREET_NAME   = src.ADDR_STREET_NAME,
  tgt.ADDR_HOUSE_NUMBER  = src.ADDR_HOUSE_NUMBER,
  tgt.ADDR_BOX_NUMBER    = src.ADDR_BOX_NUMBER,
  tgt.ADDR_POSTAL_CODE   = src.ADDR_POSTAL_CODE,
  tgt.ADDR_LOCALITY_NAME = src.ADDR_LOCALITY_NAME,
  tgt.ADDR_COUNTRY_CODE  = src.ADDR_COUNTRY_CODE,
  tgt.ORG_NUMBER         = src.ORG_NUMBER,
  tgt.DIGITAL_ADDRESS    = src.DIGITAL_ADDRESS,
  tgt.UPDATED_TIME       = src.UPDATED_TIME

WHEN NOT MATCHED THEN INSERT (
  DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME,
  ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER,
  ADDR_POSTAL_CODE, ADDR_LOCALITY_NAME, ADDR_COUNTRY_CODE,
  ORG_NUMBER, DIGITAL_ADDRESS, UPDATED_TIME

) VALUES (
  src.DD_UUID, src.EVENT_ID, src.TYP_OF_ENTY, src.FIRST_NAME,
  src.ADDR_STREET_NAME, src.ADDR_HOUSE_NUMBER, src.ADDR_BOX_NUMBER,
  src.ADDR_POSTAL_CODE, src.ADDR_LOCALITY_NAME, src.ADDR_COUNTRY_CODE,
  src.ORG_NUMBER, src.DIGITAL_ADDRESS, src.UPDATED_TIME
)
]; ORA-01400: cannot insert NULL into ("SYSTEM"."DD_ACCOUNT_TBL"."DD_UUID")

https://docs.oracle.com/error-help/db/ora-01400/
        at org.springframework.jdbc.support.SQLExceptionSubclassTranslator.doTranslate(SQLExceptionSubclassTranslator.java:97) ~[spring-jdbc-6.2.8.jar:6.2.8]
        at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:107) ~[spring-jdbc-6.2.8.jar:6.2.8]        
        at org.springframework.jdbc.core.JdbcTemplate.translateException(JdbcTemplate.java:1556) ~[spring-jdbc-6.2.8.jar:6.2.8]
        at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:677) ~[spring-jdbc-6.2.8.jar:6.2.8]
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:972) ~[spring-jdbc-6.2.8.jar:6.2.8]
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:1016) ~[spring-jdbc-6.2.8.jar:6.2.8]
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:1026) ~[spring-jdbc-6.2.8.jar:6.2.8]
        at com.ing.datadist.api.repository.AccountingDAO.insertFullOrganisationUnitWithWrapperMergeSqlServer(AccountingDAO.java:325) ~[classes/:na]
        at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]
        at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]
        at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359) ~[spring-aop-6.2.8.jar:6.2.8]
        at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196) ~[spring-aop-6.2.8.jar:6.2.8]
        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-6.2.8.jar:6.2.8]
        at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:138) ~[spring-tx-6.2.8.jar:6.2.8]      
        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184) ~[spring-aop-6.2.8.jar:6.2.8]
        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:728) ~[spring-aop-6.2.8.jar:6.2.8]
        at com.ing.datadist.api.repository.AccountingDAO$$SpringCGLIB$$0.insertFullOrganisationUnitWithWrapperMergeSqlServer(<generated>) ~[classes/:na]
        at com.ing.datadist.api.service.OrganisationUnitService.processOrganisationUnit(OrganisationUnitService.java:334) ~[classes/:na]
        at com.ing.datadist.batch.tasklet.OnePamSearchApiTasklet.execute(OnePamSearchApiTasklet.java:76) ~[classes/:na]
        at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]
        at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]
        at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359) ~[spring-aop-6.2.8.jar:6.2.8]
        at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196) ~[spring-aop-6.2.8.jar:6.2.8]
        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-6.2.8.jar:6.2.8]
        at org.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:137) ~[spring-aop-6.2.8.jar:6.2.8]
        at org.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:124) ~[spring-aop-6.2.8.jar:6.2.8]
        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184) ~[spring-aop-6.2.8.jar:6.2.8]
        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:728) ~[spring-aop-6.2.8.jar:6.2.8]
        at com.ing.datadist.batch.tasklet.OnePamSearchApiTasklet$$SpringCGLIB$$0.execute(<generated>) ~[classes/:na]
        at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:383) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:307) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:140) ~[spring-tx-6.2.8.jar:6.2.8]
        at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:250) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:82) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.batch.repeat.support.RepeatTemplate.getNextResult(RepeatTemplate.java:369) ~[spring-batch-infrastructure-5.2.2.jar:5.2.2]
        at org.springframework.batch.repeat.support.RepeatTemplate.executeInternal(RepeatTemplate.java:206) ~[spring-batch-infrastructure-5.2.2.jar:5.2.2]
        at org.springframework.batch.repeat.support.RepeatTemplate.iterate(RepeatTemplate.java:140) ~[spring-batch-infrastructure-5.2.2.jar:5.2.2]
        at org.springframework.batch.core.step.tasklet.TaskletStep.doExecute(TaskletStep.java:235) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:230) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:153) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.batch.core.job.AbstractJob.handleStep(AbstractJob.java:408) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.batch.core.job.SimpleJob.doExecute(SimpleJob.java:127) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:307) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher$1.run(TaskExecutorJobLauncher.java:155) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:50) ~[spring-core-6.2.8.jar:6.2.8]
        at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher.run(TaskExecutorJobLauncher.java:146) ~[spring-batch-core-5.2.2.jar:5.2.2]
        at com.ing.datadist.batch.schedular.BatchSchedular.run(BatchSchedular.java:50) ~[classes/:na]
        at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]
        at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]
        at org.springframework.scheduling.support.ScheduledMethodRunnable.runInternal(ScheduledMethodRunnable.java:130) ~[spring-context-6.2.8.jar:6.2.8]
        at org.springframework.scheduling.support.ScheduledMethodRunnable.lambda$run$2(ScheduledMethodRunnable.java:124) ~[spring-context-6.2.8.jar:6.2.8]
        at io.micrometer.observation.Observation.observe(Observation.java:498) ~[micrometer-observation-1.15.1.jar:1.15.1]
        at org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:124) ~[spring-context-6.2.8.jar:6.2.8]
        at org.springframework.scheduling.config.Task$OutcomeTrackingRunnable.run(Task.java:85) ~[spring-context-6.2.8.jar:6.2.8]
        at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) ~[spring-context-6.2.8.jar:6.2.8]
        at org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:96) ~[spring-context-6.2.8.jar:6.2.8]
        at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572) ~[na:na]
        at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317) ~[na:na]
        at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) ~[na:na]
        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144) ~[na:na]
        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642) ~[na:na]
        at java.base/java.lang.Thread.run(Thread.java:1583) ~[na:na]
Caused by: java.sql.SQLIntegrityConstraintViolationException: ORA-01400: cannot insert NULL into ("SYSTEM"."DD_ACCOUNT_TBL"."DD_UUID")

https://docs.oracle.com/error-help/db/ora-01400/
        at oracle.jdbc.driver.T4CTTIoer11.processError(T4CTTIoer11.java:715) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.T4CTTIoer11.processError(T4CTTIoer11.java:615) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.T4C8Oall.processError(T4C8Oall.java:1372) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:972) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:237) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.T4C8Oall.doOALL(T4C8Oall.java:524) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:298) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:1510) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.OracleStatement.executeSQLStatement(OracleStatement.java:2020) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1633) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:3973) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.OraclePreparedStatement.doExecuteLargeUpdate(OraclePreparedStatement.java:4339) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.OraclePreparedStatement.executeLargeUpdate(OraclePreparedStatement.java:4316) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.OraclePreparedStatement.executeUpdate(OraclePreparedStatement.java:4291) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at oracle.jdbc.driver.OraclePreparedStatementWrapper.executeUpdate(OraclePreparedStatementWrapper.java:1007) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        at com.zaxxer.hikari.pool.ProxyPreparedStatement.executeUpdate(ProxyPreparedStatement.java:61) ~[HikariCP-6.3.0.jar:na]
        at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.executeUpdate(HikariProxyPreparedStatement.java) ~[HikariCP-6.3.0.jar:na]
        at org.springframework.jdbc.core.JdbcTemplate.lambda$update$2(JdbcTemplate.java:977) ~[spring-jdbc-6.2.8.jar:6.2.8]
        at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:658) ~[spring-jdbc-6.2.8.jar:6.2.8]
        ... 58 common frames omitted
Caused by: oracle.jdbc.OracleDatabaseException: ORA-01400: cannot insert NULL into ("SYSTEM"."DD_ACCOUNT_TBL"."DD_UUID")

        at oracle.jdbc.driver.T4CTTIoer11.processError(T4CTTIoer11.java:723) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04]
        ... 76 common frames omitted
package com.ing.datadist.configreader;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Repository
@Slf4j
public class CofaceOpsConfigReader {

    private static final String FETCH_BY_ORG_NUMBER_SQL =
            "SELECT OPS_ORGANISATIONUNITNAME, ORG_NUMBER, ADR_POSTALADDRESS_CNTRYCD, " +
                    "ADR_POSTALADDRESS_STREETNM, ADR_POSTALADDRESS_HOUSENUM, ADR_POSTALADDRESS_HOUSEADD, " +
                    "ADR_POSTALADDRESS_POSTALCD, ADR_POSTALADDRESS_CITYNAME, " +
                    "OPS_EXTID_DATEOFISSUE, OPS_EXTID_EXPIRYDATE, " +
                    "ADR_DIGITALADDR_EMAIL " +
                    "FROM DD_COFACEOPS_TBL WHERE OPS_NUMBER = ?";

    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public CofaceOpsConfigReader(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    public List<Map<String, String>> fetchByOrgNumber(String OPS_NUMBER) {
        try{
            log.debug("Start of fetchByOrgNumber");
            log.debug("Fetching organisation unit config for Org Number: '{}'", OPS_NUMBER);

            List<Map<String, String>> results = jdbcTemplate.query(
                    FETCH_BY_ORG_NUMBER_SQL,
                    new Object[]{OPS_NUMBER},
                    new OrganisationUnitRowMapper()
            );

            log.debug("Fetched {} record(s) from DD_COFACEOPS_TBL by Org Number", results.size());
            results.forEach(row -> log.debug("Row: {}", row));
            log.debug("End of fetchByOrgNumber");
            return results;

        }catch(Exception e){
            e.printStackTrace();
            throw e;
        }

      }
    public Map<String, String> fetchAddressDetails(String uuid) {
        String sql = "SELECT ADR_POSTALADDRESS_STREETNM, ADR_POSTALADDRESS_CITYNAME, " +
                "ADR_POSTALADDRESS_POSTALCD, ADR_POSTALADDRESS_CNTRYCD " +
                "FROM DD_COFACEOPS_TBL WHERE OPS_UUID = ?";
        return jdbcTemplate.queryForObject(sql, new Object[]{uuid}, (rs, rowNum) -> {
            Map<String, String> result = new HashMap<>();
            result.put("street", rs.getString("ADR_POSTALADDRESS_STREETNM"));
            result.put("city", rs.getString("ADR_POSTALADDRESS_CITYNAME"));
            result.put("postalCode", rs.getString("ADR_POSTALADDRESS_POSTALCD"));
            result.put("country", rs.getString("ADR_POSTALADDRESS_CNTRYCD"));
            return result;
        });
    }

    public String fetchOrganisationUnitName(String orgNumber) {
        String sql = "SELECT OPS_ORGANISATIONUNITNAME FROM DD_COFACEOPS_TBL WHERE OPS_UUID = ?";
        List<String> names = jdbcTemplate.query(sql, new Object[]{orgNumber}, (rs, rowNum) -> rs.getString("OPS_ORGANISATIONUNITNAME"));
        return names.get(0);
    }
}


package com.ing.datadist.configreader;

import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import static com.ing.datadist.api.utils.DataDistributionConstants.LOGICAL_DATA_DOMAIN;
import static com.ing.datadist.api.utils.DataDistributionConstants.ORGANISATION_UNIT_NAME_TYPE;


//            "SELECT OPS_ORGANISATIONUNITNAME, ORG_NUMBER, ADR_POSTALADDRESS_CNTRYCD, " +
//                    "ADR_POSTALADDRESS_STREETNM, ADR_POSTALADDRESS_HOUSENUM, ADR_POSTALADDRESS_HOUSEADD, " +
//                    "ADR_POSTALADDRESS_POSTALCD, ADR_POSTALADDRESS_CITYNAME, " +
//                    "OPS_EXTID_DATEOFISSUE, OPS_EXTID_EXPIRYDATE, " +
//                    "ADR_DIGITALADDR_EMAIL " +
//                    "FROM DD_COFACEOPS_TBL WHERE OPS_NUMBER = ?";
public class OrganisationUnitRowMapper implements RowMapper<Map<String, String>> {
    @Override
    public Map<String, String> mapRow(ResultSet organisationUnitResultSet, int rowNum) throws SQLException {
        Map<String, String> row = new HashMap<>();
        row.put("organisationUnitName", organisationUnitResultSet.getString("OPS_ORGANISATIONUNITNAME"));
        row.put("orgNumber", organisationUnitResultSet.getString("ORG_NUMBER"));
        row.put("countryOfResidence", organisationUnitResultSet.getString("ADR_POSTALADDRESS_CNTRYCD"));
        row.put("dateOfIssue", organisationUnitResultSet.getString("OPS_EXTID_DATEOFISSUE"));
        row.put("expiryDate", organisationUnitResultSet.getString("OPS_EXTID_EXPIRYDATE"));
  //      row.put("uuid", organisationUnitResultSet.getString("OPS_UUID"));
        row.put("logicalDataDomain", LOGICAL_DATA_DOMAIN);
        row.put("organisationUnitNameType", ORGANISATION_UNIT_NAME_TYPE);
        row.put("streetName", organisationUnitResultSet.getString("ADR_POSTALADDRESS_STREETNM"));
        row.put("houseNumber", organisationUnitResultSet.getString("ADR_POSTALADDRESS_HOUSENUM"));
        row.put("houseNumberAddition", organisationUnitResultSet.getString("ADR_POSTALADDRESS_HOUSEADD"));
        row.put("postalCode", organisationUnitResultSet.getString("ADR_POSTALADDRESS_POSTALCD"));
        row.put("cityName", organisationUnitResultSet.getString("ADR_POSTALADDRESS_CITYNAME"));

        return row;
    }
}

package com.ing.datadist.api.repository;

import com.ing.datadist.api.model.CreateInvolvedPartyResponseV5;
import com.ing.datadist.api.model.InvolvedPartiesOrganisationUnitResponse;
import com.ing.datadist.domain.OrganisationUnitDomainWrapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDate;

@Repository
@Slf4j
public class AccountingDAO {

    private final JdbcTemplate jdbcTemplate;

    public AccountingDAO(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

 /*   public void updateExternalIdentifier(String uuid, String externalId) {
        String sql = "UPDATE DD_ACCOUNT_TBL SET ORG_NUMBER = ?, UPDATED_TIME = ? WHERE DD_UUID = ?";
        jdbcTemplate.update(sql, externalId, Timestamp.from(Instant.now()), uuid);
        log.info("Updated external ID for UUID={}", uuid);
    }*/


    public void updateExternalIdentifier(String uuid, String externalId) {
        String sql = """
        UPDATE DD_ACCOUNT_TBL 
        SET ORG_NUMBER = ?, UPDATED_TIME = ? 
        WHERE DD_UUID = ?
    """;
        jdbcTemplate.update(sql, externalId, Timestamp.from(Instant.now()), uuid);
    }


/*
    public void updateOrganisationUnitName(String uuid, String organisationUnitName) {
        String sql = "UPDATE DD_ACCOUNT_TBL SET FIRST_NAME = ? WHERE DD_UUID = ?";
        jdbcTemplate.update(sql, organisationUnitName, uuid);
        log.info(" Organisation unit name updated for UUID={}", uuid);
    }
*/
public void updateOrganisationUnitName(String uuid, String organisationUnitName) {

    String sql = """

        UPDATE DD_ACCOUNT_TBL 

        SET FIRST_NAME = ?, UPDATED_TIME = ? 

        WHERE DD_UUID = ?

    """;

    jdbcTemplate.update(sql, organisationUnitName, Timestamp.from(Instant.now()), uuid);

}


    /*public void updatePostalAddress(String uuid, String street, String houseNumber,
                                    String houseNumberAddition, String postalCode,
                                    String locality, String countryCode) {
        String sql = "UPDATE DD_ACCOUNT_TBL SET ADDR_STREET_NAME = ?, ADDR_HOUSE_NUMBER = ?, ADDR_BOX_NUMBER = ?, ADDR_POSTAL_CODE = ?, ADDR_LOCALITY_NAME = ?, ADDR_COUNTRY_CODE = ?, UPDATED_TIME = ? WHERE DD_UUID = ?";
        jdbcTemplate.update(sql, street, houseNumber, houseNumberAddition, postalCode, locality, countryCode, Timestamp.from(Instant.now()), uuid);
        log.info("Postal Address updated for UUID={}", uuid);
    }
*/
    public void updatePostalAddress(String uuid,

                                    String street,

                                    String houseNumber,

                                    String houseNumberAddition,

                                    String postalCode,

                                    String locality,

                                    String countryCode) {

        String sql = """

        UPDATE DD_ACCOUNT_TBL 

        SET ADDR_STREET_NAME = ?, 

            ADDR_HOUSE_NUMBER = ?, 

            ADDR_BOX_NUMBER = ?, 

            ADDR_POSTAL_CODE = ?, 

            ADDR_LOCALITY_NAME = ?, 

            ADDR_COUNTRY_CODE = ?, 

            UPDATED_TIME = ?

        WHERE DD_UUID = ?

    """;

        jdbcTemplate.update(sql,

                street,

                houseNumber,

                houseNumberAddition,

                postalCode,

                locality,

                countryCode,

                Timestamp.from(Instant.now()),

                uuid);

    }


    public void updateDigitalAddress(String uuid, String digitalAddress) {
        String sql = "UPDATE DD_ACCOUNT_TBL SET DIGITAL_ADDRESS = ?, UPDATED_TIME = ? WHERE DD_UUID = ?";
        jdbcTemplate.update(sql, digitalAddress, Timestamp.from(Instant.now()), uuid);
        log.info("Digital Address updated for UUID={}", uuid);
    }

    public void updateHierarchy(String uuid, String parentId) {
        String sql = "UPDATE DD_ACCOUNT_TBL SET LAST_NAME = ?, UPDATED_TIME = ? WHERE DD_UUID = ?";
        jdbcTemplate.update(sql, parentId, Timestamp.from(Instant.now()), uuid);
        log.info("Hierarchy updated for UUID={}", uuid);
    }

    public void createOuAccountingTableEntry(String ddUuid, String OuName) {
        String eventId = "null";
        String sql = "INSERT INTO DD_ACCOUNT_TBL(DD_UUID,FIRST_NAME, EVENT_ID) VALUES (?,?,?)";
        jdbcTemplate.update(sql, ddUuid, OuName, eventId);
        log.info("Created ou account table entry for UUID={}", ddUuid);
    }

    public void insertFullOrganisationUnit(CreateInvolvedPartyResponseV5 response) {
        InvolvedPartiesOrganisationUnitResponse orgUnit = response.getOrganisationUnit();

        String ddUuid = orgUnit.getInvolvedPartyInternalIdentifiers().get(0).getInvolvedPartyInternalIdentifierValue();
        String eventId = "null";
        String typeOfEntity = "ORG_UNIT";
        String orgName = orgUnit.getOrganisationUnitNames().get(0).getOrganisationUnitName();
        Timestamp updatedTime = Timestamp.from(Instant.now());

        String sql = "INSERT INTO DD_ACCOUNT_TBL (DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME, UPDATED_TIME) VALUES (?, ?, ?, ?, ?)";
        jdbcTemplate.update(sql, ddUuid, eventId, typeOfEntity, orgName, updatedTime);

        log.info("Inserted organisation unit record: UUID={}, EVENT_ID={}, ORG_NAME={}", ddUuid, eventId, orgName);
    }
/*

    public void insertFullOrganisationUnitWithWrapper(OrganisationUnitDomainWrapper wrapper) {

        String ddUuid = wrapper.getOpsUUID();
        String eventId = "null";
        String typeOfEntity = "ORG_UNIT";
        String orgName = wrapper.getOrganisationUnitName();
        String streetName = wrapper.getPostalAddressStreetNm();
        String houseNumber = wrapper.getPostalAddressHouseNum();
        String boxNumber = wrapper.getPostalAddressHouseNum();
        String postalCode = wrapper.getPostalAddressPostalCd();
        String countryCode = wrapper.getPostalAddressCntryCd();
        String orgNumber = wrapper.getOrgExternalIdentifierVal();
        String digitalAddress = wrapper.getDigitalAddrEmail();

        Timestamp updatedTime = Timestamp.from(Instant.now());

        String sql = "INSERT INTO DD_ACCOUNT_TBL (\n" +
                "DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME, ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER, ADDR_POSTAL_CODE," +
                " ADDR_COUNTRY_CODE, ORG_NUMBER, UPDATED_TIME, DIGITAL_ADDRESS) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        jdbcTemplate.update(sql, ddUuid, eventId, typeOfEntity, orgName, streetName, houseNumber, boxNumber, postalCode,
                countryCode, orgNumber, updatedTime, digitalAddress);

        log.info("Inserted organisation unit record using wrapper UUID={}", ddUuid);
    }
*/
/*

    public void insertFullOrganisationUnitWithWrapper(OrganisationUnitDomainWrapper wrapper) {
        String ddUuid = wrapper.getOpsUUID();
        String eventId = "null"; // Use SQL NULL
        String typeOfEntity = "ORG_UNIT";
        String orgName = wrapper.getOrganisationUnitName();
        String streetName = wrapper.getPostalAddressStreetNm();
        String houseNumber = wrapper.getPostalAddressHouseNum();
        String boxNumber = wrapper.getPostalAddressHouseAdd(); // FIXED
        String postalCode = wrapper.getPostalAddressPostalCd();
        String locality = wrapper.getPostalAddressCityName(); // ADD locality
        String countryCode = wrapper.getPostalAddressCntryCd();
        String orgNumber = wrapper.getOrgExternalIdentifierVal();
        String digitalAddress = wrapper.getDigitalAddrEmail();
        Timestamp updatedTime = Timestamp.from(Instant.now());

        String sql = """
        INSERT INTO DD_ACCOUNT_TBL (
          DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME,
          ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER,
          ADDR_POSTAL_CODE, ADDR_LOCALITY_NAME, ADDR_COUNTRY_CODE,
          ORG_NUMBER, DIGITAL_ADDRESS, UPDATED_TIME
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """;

        jdbcTemplate.update(sql, ddUuid, eventId, typeOfEntity, orgName,
                streetName, houseNumber, boxNumber, postalCode, locality,
                countryCode, orgNumber, digitalAddress, updatedTime);

        log.info("Inserted organisation unit record using wrapper UUID={}", ddUuid);
    }
*/

    public void updatePostalAddressVerificationDate(String uuid, LocalDate verificationDate) {
        String sql = "UPDATE DD_ACCOUNT_TBL SET ADDR_LAST_VERIFICATION_DATE=?, UPDATED_TIME=? WHERE DD_UUID=?";
        jdbcTemplate.update(sql, verificationDate, Timestamp.from(Instant.now()), uuid);
        log.info("Postal address verification date updated for UUID={}", uuid);

    }
    public void insertFullOrganisationUnitWithWrapper(OrganisationUnitDomainWrapper wrapper) {

        String ddUuid = wrapper.getOpsUUID();
        String eventId = "null";
        String typeOfEntity = "ORG_UNIT";
        String orgName = wrapper.getOrganisationUnitName();
        String streetName = wrapper.getPostalAddressStreetNm();
        String houseNumber = wrapper.getPostalAddressHouseNum();
        String boxNumber = wrapper.getPostalAddressHouseNum();
        String postalCode = wrapper.getPostalAddressPostalCd();
        String countryCode = wrapper.getPostalAddressCntryCd();
        String orgNumber = wrapper.getOrgExternalIdentifierVal();
        String digitalAddress = wrapper.getDigitalAddrEmail();

        Timestamp updatedTime = Timestamp.from(Instant.now());

        String sql = "INSERT INTO DD_ACCOUNT_TBL (\n" +
                "DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME, ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER, ADDR_POSTAL_CODE," +
                " ADDR_COUNTRY_CODE, ORG_NUMBER, UPDATED_TIME, DIGITAL_ADDRESS) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        jdbcTemplate.update(sql, ddUuid, eventId, typeOfEntity, orgName, streetName, houseNumber, boxNumber, postalCode,
                countryCode, orgNumber, updatedTime, digitalAddress);

        log.info("Inserted organisation unit record using wrapper UUID={}", ddUuid);
    }

    public void insertFullOrganisationUnitWithWrapperMergeSqlServer(OrganisationUnitDomainWrapper wrapper) {
        log.info("AASTHA MERGE");
        String ddUuid = wrapper.getOpsUUID();
        String eventId = "null";
        String typeOfEntity = "ORG_UNIT";
        String orgName = wrapper.getOrganisationUnitName();
        String streetName = wrapper.getPostalAddressStreetNm();
        String houseNumber = wrapper.getPostalAddressHouseNum();
        String boxNumber = wrapper.getPostalAddressHouseAdd();
        String postalCode = wrapper.getPostalAddressPostalCd();
        String locality   = wrapper.getPostalAddressCityName();
        String countryCode = wrapper.getPostalAddressCntryCd();
        String orgNumber = wrapper.getOrgExternalIdentifierVal();
        String digitalAddress = wrapper.getDigitalAddrEmail();
        Timestamp updatedTime = Timestamp.from(Instant.now());
        log.info("AASTHA MERGE2");


        String sql = """
MERGE INTO DD_ACCOUNT_TBL tgt
USING (
  SELECT ? AS DD_UUID,
         
         ? AS EVENT_ID,
         ? AS TYP_OF_ENTY,
         ? AS FIRST_NAME,
         ? AS ADDR_STREET_NAME,
         ? AS ADDR_HOUSE_NUMBER,
         ? AS ADDR_BOX_NUMBER,
         ? AS ADDR_POSTAL_CODE,
         ? AS ADDR_LOCALITY_NAME,
         ? AS ADDR_COUNTRY_CODE,
         ? AS ORG_NUMBER,
         ? AS DIGITAL_ADDRESS,
         ? AS UPDATED_TIME
           
  FROM dual
) src
ON (tgt.DD_UUID = src.DD_UUID)
WHEN MATCHED THEN UPDATE SET
  tgt.TYP_OF_ENTY        = src.TYP_OF_ENTY,
  tgt.FIRST_NAME         = src.FIRST_NAME,
  tgt.ADDR_STREET_NAME   = src.ADDR_STREET_NAME,
  tgt.ADDR_HOUSE_NUMBER  = src.ADDR_HOUSE_NUMBER,
  tgt.ADDR_BOX_NUMBER    = src.ADDR_BOX_NUMBER,
  tgt.ADDR_POSTAL_CODE   = src.ADDR_POSTAL_CODE,
  tgt.ADDR_LOCALITY_NAME = src.ADDR_LOCALITY_NAME,
  tgt.ADDR_COUNTRY_CODE  = src.ADDR_COUNTRY_CODE,
  tgt.ORG_NUMBER         = src.ORG_NUMBER,
  tgt.DIGITAL_ADDRESS    = src.DIGITAL_ADDRESS,
  tgt.UPDATED_TIME       = src.UPDATED_TIME
    
WHEN NOT MATCHED THEN INSERT (
  DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME,
  ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER,
  ADDR_POSTAL_CODE, ADDR_LOCALITY_NAME, ADDR_COUNTRY_CODE,
  ORG_NUMBER, DIGITAL_ADDRESS, UPDATED_TIME

) VALUES (
  src.DD_UUID, src.EVENT_ID, src.TYP_OF_ENTY, src.FIRST_NAME,
  src.ADDR_STREET_NAME, src.ADDR_HOUSE_NUMBER, src.ADDR_BOX_NUMBER,
  src.ADDR_POSTAL_CODE, src.ADDR_LOCALITY_NAME, src.ADDR_COUNTRY_CODE,
  src.ORG_NUMBER, src.DIGITAL_ADDRESS, src.UPDATED_TIME
)
""";

        log.info("AASTHA MERGE7");

        jdbcTemplate.update(sql, ddUuid, eventId, typeOfEntity, orgName, streetName, houseNumber, boxNumber,
                postalCode, locality, countryCode, orgNumber, digitalAddress, updatedTime);

        log.info("Upserted organisation unit record using wrapper (SQL Server MERGE) UUID={}", ddUuid);
    }

}





















package com.ing.datadist.api.service;

import com.ing.datadist.api.model.*;
import com.ing.datadist.api.repository.AccountingDAO;
import com.ing.datadist.batch.repository.MappingDAO;
import com.ing.datadist.configreader.CofaceOpsConfigReader;
import com.ing.datadist.domain.OrganisationUnitDomainWrapper;
import com.ing.datadist.kafka.util.EventTransactionType;
import com.ing.datadist.kafka.util.NotificationStatus;
import com.twitter.finagle.http.Response;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import static com.ing.datadist.api.utils.DataDistributionConstants.*;

@Service
@Slf4j
public class OrganisationUnitService {

    private final OnePamRepository onePamRepository;
    private final CofaceOpsConfigReader configReader;
    private final AddressService addressService;
    private final DigitalAddrService digitalAddrService;
    private final AccountingDAO accountingDAO;
    private final MappingDAO mappingDAO;
    Instant effectiveDateSet = Instant.now()
            .minusSeconds(120) // safety margin
            .truncatedTo(ChronoUnit.SECONDS);

    Instant endDateSet = effectiveDateSet.plus(3652, ChronoUnit.DAYS);

    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("dd-MM-yyyy");

    public OrganisationUnitService(OnePamRepository onePamRepository,
                                   CofaceOpsConfigReader configReader,
                                   AddressService addressService,
                                   DigitalAddrService digitalAddrService,
                                   AccountingDAO accountingDAO,
                                   MappingDAO mappingDAO) {
        this.onePamRepository = onePamRepository;
        this.configReader = configReader;
        this.addressService = addressService;
        this.digitalAddrService = digitalAddrService;
        this.accountingDAO = accountingDAO;
        this.mappingDAO = mappingDAO;
    }
//-----comment---------------------------
   /* public void processOrganisationUnit(String orgNumber) throws Exception {
        CreatePostalAddressRequest postalRequest = new CreatePostalAddressRequest();
        CreateDigitalAddressV5Request digitalRequest = new CreateDigitalAddressV5Request("", "", "", "");
        UpdateExternalIdentifierOrganisationUnitRequest externalIdRequest = new UpdateExternalIdentifierOrganisationUnitRequest();
        CreateOrganisationUnitRequest orgUnitRequest = new CreateOrganisationUnitRequest();

        processOrganisationUnit(orgNumber, postalRequest, digitalRequest, externalIdRequest, orgUnitRequest);
    }*/
    //-----------------comment---------------------
//
//    public void processOrganisationUnit(String orgNumber,
//                                        CreatePostalAddressRequest postalRequest,
//                                        CreateDigitalAddressV5Request digitalRequest,
//                                        UpdateExternalIdentifierOrganisationUnitRequest externalIdRequest,
//                                        CreateOrganisationUnitRequest orgUnitRequest) {
//
//
//// Fetch config from DD_COFACEOPS_TBL
//        Map<String, String> config = getConfig(orgNumber);
//
//// Build wrapper from config
//        OrganisationUnitDomainWrapper wrapper = new OrganisationUnitDomainWrapper();
//        wrapper.setOpsUUID(UUID.randomUUID().toString()); // or use OPS_UUID from config if available
//        wrapper.setOrgExternalIdentifierVal(config.get("ORG_NUMBER"));
//        wrapper.setOrganisationUnitName(decodeHtml(config.get("OPS_ORGANISATIONUNITNAME")));
//        wrapper.setPostalAddressStreetNm(config.get("ADR_POSTALADDRESS_STREETNM"));
//        wrapper.setPostalAddressHouseNum(config.get("ADR_POSTALADDRESS_HOUSENUM"));
//        wrapper.setPostalAddressHouseAdd(config.get("ADR_POSTALADDRESS_HOUSEADD"));
//        wrapper.setPostalAddressPostalCd(config.get("ADR_POSTALADDRESS_POSTALCD"));
//        wrapper.setPostalAddressCityName(config.get("ADR_POSTALADDRESS_CITYNAME"));
//        wrapper.setPostalAddressCntryCd(normalizeCountryCode(config.get("ADR_POSTALADDRESS_CNTRYCD")));
//        wrapper.setOpsExtIdDateOfIssue(config.get("OPS_EXTID_DATEOFISSUE"));
//        wrapper.setOpsExtIdExpiryDate(config.get("OPS_EXTID_EXPIRYDATE"));
//        wrapper.setDigitalAddrEmail(config.get("ADR_DIGITALADDR_EMAIL"));
//
//// Insert full record immediately with all fields
//        accountingDAO.insertFullOrganisationUnitWithWrapper(wrapper);
//
//// Then proceed with OnePam API call
//        CreateInvolvedPartyResponseV5 response = createOrganisationUnit(orgNumber);
//
//        String uuid = "";
//        CreateInvolvedPartyResponseV5 response = createOrganisationUnit(orgNumber);
//        accountingDAO.insertFullOrganisationUnit(response);
//        InvolvedPartiesOrganisationUnitResponse getOrganisationUnit = response.getOrganisationUnit();
//        List<InternalIdentifierResponse> involvedPartyInternalIdentifiers = getOrganisationUnit.getInvolvedPartyInternalIdentifiers();
//        for (InternalIdentifierResponse internalIdentifierResponse : involvedPartyInternalIdentifiers ) {
//            uuid = internalIdentifierResponse.getInvolvedPartyInternalIdentifierValue();
//        }
//        log.info("Involved Party Internal Identifiers : " + uuid);
//        if (uuid == null || uuid.isBlank() || uuid.isEmpty()) {
//            log.warn("No involvedPartyIdentifier found in response. Skipping OU flow.");
//            return;
//        }
//
//        UpdateExternalIdentifierOrganisationUnitRequest updateRequest = buildUpdateRequest(orgNumber);
//
//        String finalUuid = uuid;
//        log.info("final uuid: " + finalUuid);
//        CompletableFuture<Void> updateExternalIdentifierAsync = CompletableFuture.runAsync(() -> {
//            try {
//                accountingDAO.updateExternalIdentifier(finalUuid, updateRequest.getInvolvedPartyExternalIdentifierValue());
//                mappingDAO.insertEventTrack(orgNumber, "OrganisationUpdateExternalIdentifierAPI",
//                        EventTransactionType.CREATE_ORG_UNIT.getLabel(), NotificationStatus.PENDING.name());
//
//                Response responseUpdateExternalIdentifier =
//                onePamRepository.updateExternalIdentifier(finalUuid, updateRequest).get();
//
//                if(responseUpdateExternalIdentifier.statusCode() >= 200 && responseUpdateExternalIdentifier.statusCode() < 300) {
//                    mappingDAO.insertEventTrack(orgNumber, "OrganisationUpdateExternalIdentifierAPI",
//                            EventTransactionType.CREATE_ORG_UNIT.getLabel(), NotificationStatus.RECEIVED.name());
//                    if( mappingDAO.findPendingNotifications(orgNumber).isEmpty())
//                    {
//                        mappingDAO.insertFinalStatus(orgNumber, "SUCCESS");
//                        log.info(" FINAL STATUS INSERTED for {}", finalUuid);
//                    }
//                }else{
//                    log.error("Failed to update external identifier for external identifier: " + orgNumber);
//                }
//
//            } catch (Exception e) {
//                log.error("External ID update failed for UUID={} : {}", finalUuid, e.getMessage(), e);
//            }
//        });
//
//
//        String finalUuid1 = uuid;
//        CompletableFuture<Void> createPostalAddressAsync = CompletableFuture.runAsync(() -> {
//            try {
//                accountingDAO.updatePostalAddress(finalUuid1, postalRequest.getStreetName(),postalRequest.getHouseNumber(),
//                        postalRequest.getHouseNumberAddition(),postalRequest.getPostalCode(),postalRequest.getCityName(),postalRequest.getCountryCode());
//                mappingDAO.insertEventTrack(orgNumber, "OrganisationUnitPostalAddressAPI",
//                        EventTransactionType.CREATE_ORG_UNIT_POSTAL_ADDRESS.getLabel(), NotificationStatus.PENDING.name());
//
//                PostalAddressResponse addr = addressService.createPostalAddress(finalUuid1);
//                if (addr != null) {
//                    accountingDAO.updatePostalAddress(finalUuid1,
//                            addr.getStreetName(),
//                            addr.getHouseNumber(),
//                            addr.getHouseNumberAddition(),
//                            addr.getPostalCode(),
//                            addr.getCityName(),
//                            addr.getCountryCode());
//                    log.info("Postal address created for UUID={}", finalUuid1);
//
//                    mappingDAO.insertEventTrack(orgNumber, "OrganisationUnitPostalAddressAPI",
//                            EventTransactionType.CREATE_ORG_UNIT_POSTAL_ADDRESS.getLabel(), NotificationStatus.RECEIVED.name());
//                    if( mappingDAO.findPendingNotifications(orgNumber).isEmpty())
//                    {
//                        mappingDAO.insertFinalStatus(orgNumber, "SUCCESS");
//                        log.info(" FINAL STATUS INSERTED for {}", orgNumber);
//                    }
//                } else {
//                    log.warn("Postal address response was null for UUID={}", finalUuid1);
//                }
//            } catch (Exception e) {
//                log.error("Postal address create failed for UUID={} : {}", finalUuid1, e.getMessage(), e);
//            }
//        });
//----------------------------------------------WORKING PARALLEL-----------------------------
//----------------------------------------------WORKING PARALLEL-----------------------------
//----------------------------------------------WORKING PARALLEL-----------------------------
//----------------------------------------------WORKING PARALLEL-----------------------------
//----------------------------------------------WORKING PARALLEL-----------------------------
//----------------------------------------------WORKING PARALLEL-----------------------------


//public void processOrganisationUnit(String orgNumber,
//                                    CreatePostalAddressRequest postalRequest,
//                                    CreateDigitalAddressV5Request digitalRequest,
//                                    UpdateExternalIdentifierOrganisationUnitRequest externalIdRequest,
//                                    CreateOrganisationUnitRequest orgUnitRequest) throws ExecutionException, InterruptedException {
/*
    // 1. Fetch config

    Map<String, String> config = getConfig("2355630548");
    log.info("AASTHA CONFIG" + orgNumber);

    // 2. Build wrapper for local DB insert
    OrganisationUnitDomainWrapper wrapper = new OrganisationUnitDomainWrapper();
    wrapper.setOpsUUID(config.get("OPS_UUID"));
    wrapper.setOrgExternalIdentifierVal(config.get("orgNumber"));
    log.info("AASTHA DOMAIN CONFIG" + config.get("orgNumber"));
    wrapper.setOrganisationUnitName(decodeHtml(config.get("organisationUnitName")));
    log.info("AASTHA ORG NNUMBER " + config.get("organisationUnitName"));
    wrapper.setPostalAddressStreetNm(config.get("streetName"));
    log.info("AASTHA ORG NNUMBER " + config.get("streetName"));
    wrapper.setPostalAddressHouseNum(config.get("ADR_POSTALADDRESS_HOUSENUM"));
    wrapper.setPostalAddressHouseAdd(config.get("ADR_POSTALADDRESS_HOUSEADD"));
    wrapper.setPostalAddressPostalCd(config.get("ADR_POSTALADDRESS_POSTALCD"));
    wrapper.setPostalAddressCityName(config.get("ADR_POSTALADDRESS_CITYNAME"));
    wrapper.setPostalAddressCntryCd(normalizeCountryCode(config.get("ADR_POSTALADDRESS_CNTRYCD")));
    wrapper.setOpsExtIdDateOfIssue(config.get("OPS_EXTID_DATEOFISSUE"));
    wrapper.setOpsExtIdExpiryDate(config.get("OPS_EXTID_EXPIRYDATE"));
    wrapper.setDigitalAddrEmail(config.get("ADR_DIGITALADDR_EMAIL"));

    // 3. Insert into SQL (MERGE)
    accountingDAO.insertFullOrganisationUnitWithWrapperMergeSqlServer(wrapper);

    // 4. Create OU using OnePam
    CreateInvolvedPartyResponseV5 response = createOrganisationUnit(orgNumber);

    // Extract UUID
    String uuid = response.getOrganisationUnit()
            .getInvolvedPartyInternalIdentifiers()
            .stream()
            .findFirst()
            .map(InternalIdentifierResponse::getInvolvedPartyInternalIdentifierValue)
            .orElse(null);

    if (uuid == null || uuid.isBlank()) {
        return; // Stop if UUID not returned
    }

    // 5. Update External Identifier (Sequential)
    UpdateExternalIdentifierOrganisationUnitRequest updateRequest = buildUpdateRequest(uuid);
    onePamRepository.updateExternalIdentifier(uuid, updateRequest).get();
    accountingDAO.updateExternalIdentifier(uuid, updateRequest.getInvolvedPartyExternalIdentifierValue());

    // 6. Create Postal Address (Sequential)
    PostalAddressResponse addr = addressService.createPostalAddress(uuid);
    if (addr != null) {
        accountingDAO.updatePostalAddress(uuid, addr.getStreetName(), addr.getHouseNumber(),
                addr.getHouseNumberAddition(), addr.getPostalCode(), addr.getCityName(), addr.getCountryCode());
    }
}
/*
    {
    // 7. Digital Address (Optional)
    // digitalAddrService.createDigitalAddress(uuid, digitalRequest);


        /*String finalUuid2 = uuid;
        CompletableFuture<Void> createDigitalAddressAsync = CompletableFuture.runAsync(() -> {
            try {
                accountingDAO.updateDigitalAddress(finalUuid2, digitalRequest.getFullDigitalAddress());
                mappingDAO.insertEventTrack(finalUuid2, "OrganisationUnitDigitalAddressAPI",
                        EventTransactionType.CREATE_ORG_UNIT_DIGITAL_ADDRESS.getLabel(), NotificationStatus.PENDING.name());

                DigitalAddressResponse dar = digitalAddrService.createDigitalAddress(finalUuid2, digitalRequest);
                if (dar != null && dar.getFullDigitalAddress() != null && !dar.getFullDigitalAddress().isBlank()) {
                    log.info("Digital address created for UUID={}", finalUuid2);
                    mappingDAO.insertEventTrack(finalUuid2, "OrganisationUnitDigitalAddressAPI",
                            EventTransactionType.CREATE_ORG_UNIT_DIGITAL_ADDRESS.getLabel(), NotificationStatus.RECEIVED.name());
                } else {
                    log.warn("Digital address response was null or empty for UUID={}", finalUuid2);
                }
            } catch (Exception e) {
                log.error("Digital address create failed for UUID={} : {}", finalUuid2, e.getMessage(), e);
            }
        });

    //    CompletableFuture.allOf(updateExternalIdentifierAsync, createPostalAddressAsync).join();
//                createDigitalAddressAsync)

        log.info("All parallel operations completed for organisation unit uuid={}", uuid);

        //--------------------------------parallel flow ends--------------------------------------------------------------





        String finalUuid3 = uuid;
        final String parentId = "a8eb7b57-9780-41b8-a552-3b2388ebeaad"; // Replace with real parent UUID after LE created
        if (parentId != null && !parentId.isEmpty()) {
        //    try {
                accountingDAO.updateHierarchy(uuid, parentId);
                mappingDAO.insertEventTrack(uuid, "OrganisationUnitHierarchyAPI",
                        EventTransactionType.CREATE_ORG_HIERARCHY.getLabel(), NotificationStatus.PENDING.name());
                Response response1 = createOrganisationUnitHierarchy(uuid, parentId);
             //   if (response1.statusCode() >= 200 && response1.statusCode() < 300) {
                    mappingDAO.insertEventTrack(uuid, "OrganisationUnitHierarchyAPI",
                            EventTransactionType.CREATE_ORG_HIERARCHY.getLabel(), NotificationStatus.RECEIVED.name());
//                }
//            } catch (Exception e) {
//                log.error("Hierarchy creation failed for UUID={} : {}", uuid, e.getMessage(), e);
//            }
        } else {
            log.info("No parent UUID present for {}", uuid);
        }
}
*/
public void processOrganisationUnit(String orgNumber
//                                    CreatePostalAddressRequest postalRequest,
//                                    CreateDigitalAddressV5Request digitalRequest,
//                                    UpdateExternalIdentifierOrganisationUnitRequest externalIdRequest,
//                                    CreateOrganisationUnitRequest orgUnitRequest
                              //      OrganisationUnitOrganisationRelationshipRequest req
                                    ) throws Exception {

    // 1. FETCH CONFIG
    Map<String, String> config = getConfig(orgNumber);
    log.info("CONFIG LOADED FOR ORG={} -> {}", orgNumber, config);

    // 2. BUILD WRAPPER (MERGE INTO SQL)
    OrganisationUnitDomainWrapper wrapper = new OrganisationUnitDomainWrapper();
    log.info("AASTHA UUID" + orgNumber);
    log.info("AASTHA UUID WRAPPER" + wrapper.getOpsUUID());
    wrapper.setOpsUUID(config.get("orgNumber"));
    wrapper.setOrgExternalIdentifierVal(config.get("orgNumber"));
    log.info("AASTHA ORG_NUMBER " + config.get("orgNumber"));
    wrapper.setOrganisationUnitName(decodeHtml(config.get("organisationUnitName")));
    log.info("AASTHA ORG NAME" + config.get("organisationUnitName"));
    wrapper.setPostalAddressStreetNm(config.get("ADR_POSTALADDRESS_STREETNM"));
    log.info("AASTHA STREET NAME" + config.get("streetName"));
    wrapper.setPostalAddressHouseNum(config.get("ADR_POSTALADDRESS_HOUSENUM"));
    wrapper.setPostalAddressHouseAdd(config.get("ADR_POSTALADDRESS_HOUSEADD"));
    wrapper.setPostalAddressPostalCd(config.get("ADR_POSTALADDRESS_POSTALCD"));
    wrapper.setPostalAddressCityName(config.get("ADR_POSTALADDRESS_CITYNAME"));
    wrapper.setPostalAddressCntryCd(normalizeCountryCode(config.get("ADR_POSTALADDRESS_CNTRYCD")));
    wrapper.setOpsExtIdDateOfIssue(config.get("OPS_EXTID_DATEOFISSUE"));
    wrapper.setOpsExtIdExpiryDate(config.get("OPS_EXTID_EXPIRYDATE"));
    wrapper.setDigitalAddrEmail(config.get("ADR_DIGITALADDR_EMAIL"));

    accountingDAO.insertFullOrganisationUnitWithWrapperMergeSqlServer(wrapper);

    // 3. CREATE OU
    CreateInvolvedPartyResponseV5 response = createOrganisationUnit(orgNumber);

    // 4. EXTRACT UUID SAFELY
    String uuid = response.getOrganisationUnit()
            .getInvolvedPartyInternalIdentifiers()
            .stream()
            .findFirst()
            .map(InternalIdentifierResponse::getInvolvedPartyInternalIdentifierValue)
            .orElse(null);

    if (uuid == null || uuid.isBlank()) {
        log.error("NO UUID returned for ORG={}. Stopping flow.", orgNumber);
        return;
    }
    log.info("UUID extracted for ORG {} => {}", orgNumber, uuid);

    // 5. UPDATE EXTERNAL IDENTIFIER (SEQUENTIAL)
    UpdateExternalIdentifierOrganisationUnitRequest updateRequest =
            UpdateExternalIdentifierOrganisationUnitRequest.builder()
                    .involvedPartyExternalIdentifierType(EXTERNAL_ID_TYPE)
                    .involvedPartyExternalIdentifierValue(config.get("ORG_NUMBER"))
                    .build();

    Response extIdResp = onePamRepository.updateExternalIdentifier(uuid, updateRequest).get();

    if (extIdResp.statusCode() >= 200 && extIdResp.statusCode() < 300) {
        accountingDAO.updateExternalIdentifier(uuid, config.get("ORG_NUMBER"));
    } else {
        log.error("External ID update FAILED for UUID={} status={}", uuid, extIdResp.statusCode());
        return;
    }

    // 6. CREATE POSTAL ADDRESS (SEQUENTIAL)
    PostalAddressResponse addr = addressService.createPostalAddress(uuid);
    if (addr != null) {
        accountingDAO.updatePostalAddress(
                uuid,
                addr.getStreetName(),
                addr.getHouseNumber(),
                addr.getHouseNumberAddition(),
                addr.getPostalCode(),
                addr.getCityName(),
                addr.getCountryCode()
        );
    }
//
//    // 7. OPTIONAL DIGITAL ADDRESS
//    if (digitalRequest != null && digitalRequest.getFullDigitalAddress() != null) {
//        DigitalAddressResponse dar = digitalAddrService.createDigitalAddress(uuid, digitalRequest);
//        if (dar != null) {
//            accountingDAO.updateDigitalAddress(uuid, dar.getFullDigitalAddress());
//        }
//    }

    // 8. HIERARCHY CREATION (SEQUENTIAL)
    final String parentId = "a8eb7b57-9780-41b8-a552-3b2388ebeaad";

    accountingDAO.updateHierarchy(uuid, parentId);
    mappingDAO.insertEventTrack(uuid, "OrganisationUnitHierarchyAPI",
            EventTransactionType.CREATE_ORG_HIERARCHY.getLabel(), NotificationStatus.PENDING.name());

    Response hierResp = createOrganisationUnitHierarchy(uuid, parentId);

    mappingDAO.insertEventTrack(uuid, "OrganisationUnitHierarchyAPI",
            EventTransactionType.CREATE_ORG_HIERARCHY.getLabel(), NotificationStatus.RECEIVED.name());

    log.info("SEQUENTIAL FLOW COMPLETE for UUID={}", uuid);
}




    private CreateInvolvedPartyResponseV5 createOrganisationUnit(String uuid) {

        String organisationUnitName = String.valueOf(configReader.fetchOrganisationUnitName(uuid));

        Map<String, String> config = getConfig(uuid);
        CreateInvolvedPartyRequestV5 request = CreateInvolvedPartyRequestV5.builder()
                .organisationUnit(
                        CreateOrganisationUnitRequest.builder()
                        .dataSource(DATA_SOURCE)
                        .logicalDataDomain(LOGICAL_DATA_DOMAIN)
                        .countryOfResidence(config.get("countryOfResidence"))
                        .preferredLanguage(LANGUAGE)
                        .channelOfEntry(CHANNEL_OF_ENTRY)
                        .organisationUnitStructureType(STRUCTURE_TYPE)
                        .effectiveDate(config.get("dateOfIssue"))
                                .involvedPartyInternalIdentifiers(Collections.singletonList(
                                        CreateInternalIdentifierRequest.builder()
                                                .involvedPartyInternalIdentifierType("CSI_BE")
                                                .involvedPartyInternalIdentifierValue(config.get(uuid))
                                                .build()))
                        .organisationUnitNames(Collections.singletonList(
                                CreateOrganisationUnitNameRequest.builder()
                                        .organisationUnitNameType(ORGANISATION_UNIT_NAME_TYPE)
                                        .organisationUnitName(organisationUnitName)
                                        .build()))
                        .build())
                .build();
        try {
            accountingDAO.createOuAccountingTableEntry(uuid,organisationUnitName);
            mappingDAO.insertEventTrack(uuid, "CreateOrganisationUnitApi",
                    EventTransactionType.CREATE_ORG_UNIT.getLabel(), NotificationStatus.PENDING.name());

            CreateInvolvedPartyResponseV5 responseV5 = onePamRepository.createInvolvedParty(request).get();

            mappingDAO.insertEventTrack(uuid, "CreateOrganisationUnitApi",
                    EventTransactionType.CREATE_ORG_UNIT.getLabel(), NotificationStatus.RECEIVED.name());
            if( mappingDAO.findPendingNotifications(uuid).isEmpty())
            {
                mappingDAO.insertFinalStatus(uuid, "SUCCESS");
                log.info(" FINAL STATUS INSERTED for {}", uuid);
            }
            return responseV5;
        } catch (Exception e) {
            log.error("Failed to create organisation unit for uuid={}: {}", uuid, e.getMessage(), e);
            throw new RuntimeException(e);
        }
    }

    private UpdateExternalIdentifierOrganisationUnitRequest buildUpdateRequest(String uuid) {
        Map<String, String> config = getConfig(uuid);
        return UpdateExternalIdentifierOrganisationUnitRequest.builder()
                .involvedPartyExternalIdentifierType(EXTERNAL_ID_TYPE)
                .involvedPartyExternalIdentifierValue(config.getOrDefault("ORG_NUMBER", uuid))
                .countryOfIssue(config.get("countryOfResidence"))
                .placeOfIssue(PLACE_OF_ISSUE)
                .dateOfIssue(config.get("dateOfIssue"))
                .expiryDate(config.get("expiryDate"))
                .dataSource(DATA_SOURCE)
                .effectiveDate(effectiveDateSet.toString())
                .endDate(endDateSet.toString())
                .build();
    }

//    private Response createOrganisationUnitHierarchy(String childId, String parentId) {
//        OrganisationUnitOrganisationRelationshipRequest request = OrganisationUnitOrganisationRelationshipRequest.builder()
//                .childOrganisationUnitIdentifier(childId)
//                .parentOrganisationIdentifier(parentId)
//             //   .parentRoleReasonType(ROLE_REASON_TYPE)
//                .dataSource(DATA_SOURCE)
//                .build();
//        try {
//            Response response = onePamRepository.createOrganisationUnitHierarchy(request).get();
//            log.info("Successfully created hierarchy between child: {} and parent: {}", childId, parentId);
//            return response;
//        } catch (Exception e) {
//            log.error("Failed to create organisation unit hierarchy", e);
//            throw new RuntimeException("Hierarchy creation failed", e);
//        }
//    }


    private Response createOrganisationUnitHierarchy(String childId, String parentId) {
        OrganisationUnitOrganisationRelationshipRequest relationshipRequest =
                OrganisationUnitOrganisationRelationshipRequest.builder()
                        .childOrganisationUnitIdentifier(childId)
                        .parentOrganisationIdentifier(parentId)
                        .parentRoleReasonType("CPTL_CTRL") // Replace with constant if needed
                        .dataSource("FOS_IT") // Replace with constant if needed
                        .build();

        OrganisationUnitOrganisationRelationshipRequestV1 wrapper =
                OrganisationUnitOrganisationRelationshipRequestV1.builder()
                        .organisationUnitOrganisationRelationship(relationshipRequest)
                        .build();

        try {
            Response response = onePamRepository.createOrganisationUnitHierarchy(wrapper).get();
            log.info("Successfully created hierarchy between child: {} and parent: {}", childId, parentId);
            return response;
        } catch (Exception e) {
            log.error("Failed to create organisation unit hierarchy", e);
            throw new RuntimeException("Hierarchy creation failed", e);
        }
    }

    private Map<String, String> getConfig(String orgNumber) {
        try{
            List<Map<String, String>> list = configReader.fetchByOrgNumber(orgNumber);
            return list.isEmpty() ? Collections.emptyMap() : list.get(0);
        } catch (Exception e){
            e.printStackTrace();
            throw e;
        }

    }

    private String decodeHtml(String s) {
        return (s == null) ? null : s.replace("&amp;", "&").trim();
    }

    private String normalizeCountryCode(String s) {
        if (s == null || s.isBlank()) return null;
        return "000".equals(s.trim()) ? "BE" : s.trim().toUpperCase();
    }

}

