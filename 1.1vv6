2025-12-02T23:18:02.356+05:30 DEBUG 11448 --- [Integration-Module] [   scheduling-1] c.i.d.c.CofaceOpsConfigReader            : End of fetchByOrgNumber 2025-12-02T23:18:02.356+05:30  INFO 11448 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA CONFIGe126cb6c-8cc3-4202-8deb-8a0a0c219b86 2025-12-02T23:18:02.357+05:30  INFO 11448 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA DOMAIN CONFIG1005791317 2025-12-02T23:18:02.357+05:30  INFO 11448 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA ORG NNUMBER Van De Weghe, Tessa 2025-12-02T23:18:02.357+05:30  INFO 11448 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA ORG NNUMBER Heirweg 2025-12-02T23:18:02.358+05:30  INFO 11448 --- [Integration-Module] [   scheduling-1] c.i.d.api.repository.AccountingDAO       : AASTHA MERGE 2025-12-02T23:18:02.358+05:30  INFO 11448 --- [Integration-Module] [   scheduling-1] c.i.d.api.repository.AccountingDAO       : AASTHA MERGE2 2025-12-02T23:18:02.358+05:30  INFO 11448 --- [Integration-Module] [   scheduling-1] c.i.d.api.repository.AccountingDAO       : AASTHA MERGE7 2025-12-02T23:18:02.498+05:30  INFO 11448 --- [Integration-Module] [ntainer#7-0-C-1] org.apache.kafka.clients.NetworkClient   : [Consumer clientId=consumer-onepam_test_group_local-005-2, groupId=onepam_test_group_local-005] Node -2 disconnected. 2025-12-02T23:18:02.498+05:30  WARN 11448 --- [Integration-Module] [ntainer#7-0-C-1] org.apache.kafka.clients.NetworkClient   : [Consumer clientId=consumer-onepam_test_group_local-005-2, groupId=onepam_test_group_local-005] Connection to node -2 (br401-odin-tst.ic.ing.net/10.159.96.99:9092) could not be established. Node may not be available. 2025-12-02T23:18:02.498+05:30  WARN 11448 --- [Integration-Module] [ntainer#7-0-C-1] org.apache.kafka.clients.NetworkClient   : [Consumer clientId=consumer-onepam_test_group_local-005-2, groupId=onepam_test_group_local-005] Bootstrap broker br401-odin-tst.ic.ing.net:9092 (id: -2 rack: null) disconnected 2025-12-02T23:18:02.854+05:30 ERROR 11448 --- [Integration-Module] [   scheduling-1] c.i.d.b.tasklet.OnePamSearchApiTasklet   : Exception occurred while executing API call for UUID :e126cb6c-8cc3-4202-8deb-8a0a0c219b86 error :{} org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [MERGE INTO DD_ACCOUNT_TBL tgt USING ( SELECT ? AS DD_UUID, log.info("AASTHA MERGE3"); ? AS EVENT_ID, ? AS TYP_OF_ENTY, ? AS FIRST_NAME, ? AS ADDR_STREET_NAME, ? AS ADDR_HOUSE_NUMBER, ? AS ADDR_BOX_NUMBER, ? AS ADDR_POSTAL_CODE, ? AS ADDR_LOCALITY_NAME, ? AS ADDR_COUNTRY_CODE, ? AS ORG_NUMBER, ? AS DIGITAL_ADDRESS, ? AS UPDATED_TIME log.info("AASTHA MERGE4"); FROM dual ) src ON (tgt.DD_UUID = src.DD_UUID) WHEN MATCHED THEN UPDATE SET tgt.TYP_OF_ENTY        = src.TYP_OF_ENTY, tgt.FIRST_NAME         = src.FIRST_NAME, tgt.ADDR_STREET_NAME   = src.ADDR_STREET_NAME, tgt.ADDR_HOUSE_NUMBER  = src.ADDR_HOUSE_NUMBER, tgt.ADDR_BOX_NUMBER    = src.ADDR_BOX_NUMBER, tgt.ADDR_POSTAL_CODE   = src.ADDR_POSTAL_CODE, tgt.ADDR_LOCALITY_NAME = src.ADDR_LOCALITY_NAME, tgt.ADDR_COUNTRY_CODE  = src.ADDR_COUNTRY_CODE, tgt.ORG_NUMBER         = src.ORG_NUMBER, tgt.DIGITAL_ADDRESS    = src.DIGITAL_ADDRESS, tgt.UPDATED_TIME       = src.UPDATED_TIME log.info("AASTHA MERGE5"); WHEN NOT MATCHED THEN INSERT ( DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME, ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER, ADDR_POSTAL_CODE, ADDR_LOCALITY_NAME, ADDR_COUNTRY_CODE, ORG_NUMBER, DIGITAL_ADDRESS, UPDATED_TIME log.info("AASTHA MERGE6"); ) VALUES ( src.DD_UUID, src.EVENT_ID, src.TYP_OF_ENTY, src.FIRST_NAME, src.ADDR_STREET_NAME, src.ADDR_HOUSE_NUMBER, src.ADDR_BOX_NUMBER, src.ADDR_POSTAL_CODE, src.ADDR_LOCALITY_NAME, src.ADDR_COUNTRY_CODE, src.ORG_NUMBER, src.DIGITAL_ADDRESS, src.UPDATED_TIME ) ] at org.springframework.jdbc.support.SQLExceptionSubclassTranslator.doTranslate(SQLExceptionSubclassTranslator.java:103) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:107) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.translateException(JdbcTemplate.java:1556) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:677) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:972) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:1016) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:1026) ~[spring-jdbc-6.2.8.jar:6.2.8] at com.ing.datadist.api.repository.AccountingDAO.insertFullOrganisationUnitWithWrapperMergeSqlServer(AccountingDAO.java:329) ~[classes/:na] at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na] at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na] at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:138) ~[spring-tx-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:728) ~[spring-aop-6.2.8.jar:6.2.8] at com.ing.datadist.api.repository.AccountingDAO$$SpringCGLIB$$0.insertFullOrganisationUnitWithWrapperMergeSqlServer(<generated>) ~[classes/:na] at com.ing.datadist.api.service.OrganisationUnitService.processOrganisationUnit(OrganisationUnitService.java:215) ~[classes/:na] at com.ing.datadist.api.service.OrganisationUnitService.processOrganisationUnit(OrganisationUnitService.java:65) ~[classes/:na] at com.ing.datadist.batch.tasklet.OnePamSearchApiTasklet.execute(OnePamSearchApiTasklet.java:76) ~[classes/:na] at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na] at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na] at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:137) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:124) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:728) ~[spring-aop-6.2.8.jar:6.2.8] at com.ing.datadist.batch.tasklet.OnePamSearchApiTasklet$$SpringCGLIB$$0.execute(<generated>) ~[classes/:na] at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:383) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:307) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:140) ~[spring-tx-6.2.8.jar:6.2.8] at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:250) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:82) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.repeat.support.RepeatTemplate.getNextResult(RepeatTemplate.java:369) ~[spring-batch-infrastructure-5.2.2.jar:5.2.2] at org.springframework.batch.repeat.support.RepeatTemplate.executeInternal(RepeatTemplate.java:206) ~[spring-batch-infrastructure-5.2.2.jar:5.2.2] at org.springframework.batch.repeat.support.RepeatTemplate.iterate(RepeatTemplate.java:140) ~[spring-batch-infrastructure-5.2.2.jar:5.2.2] at org.springframework.batch.core.step.tasklet.TaskletStep.doExecute(TaskletStep.java:235) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:230) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:153) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.job.AbstractJob.handleStep(AbstractJob.java:408) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.job.SimpleJob.doExecute(SimpleJob.java:127) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:307) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher$1.run(TaskExecutorJobLauncher.java:155) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:50) ~[spring-core-6.2.8.jar:6.2.8] at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher.run(TaskExecutorJobLauncher.java:146) ~[spring-batch-core-5.2.2.jar:5.2.2] at com.ing.datadist.batch.schedular.BatchSchedular.run(BatchSchedular.java:50) ~[classes/:na] at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na] at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na] at org.springframework.scheduling.support.ScheduledMethodRunnable.runInternal(ScheduledMethodRunnable.java:130) ~[spring-context-6.2.8.jar:6.2.8] at org.springframework.scheduling.support.ScheduledMethodRunnable.lambda$run$2(ScheduledMethodRunnable.java:124) ~[spring-context-6.2.8.jar:6.2.8] at io.micrometer.observation.Observation.observe(Observation.java:498) ~[micrometer-observation-1.15.1.jar:1.15.1] at org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:124) ~[spring-context-6.2.8.jar:6.2.8] at org.springframework.scheduling.config.Task$OutcomeTrackingRunnable.run(Task.java:85) ~[spring-context-6.2.8.jar:6.2.8] at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) ~[spring-context-6.2.8.jar:6.2.8] at org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:96) ~[spring-context-6.2.8.jar:6.2.8] at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572) ~[na:na] at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317) ~[na:na] at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) ~[na:na] at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144) ~[na:na] at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642) ~[na:na] at java.base/java.lang.Thread.run(Thread.java:1583) ~[na:na] Caused by: java.sql.SQLSyntaxErrorException: ORA-00923: FROM keyword not found where expected https://docs.oracle.com/error-help/db/ora-00923/ at oracle.jdbc.driver.T4CTTIoer11.processError(T4CTTIoer11.java:715) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4CTTIoer11.processError(T4CTTIoer11.java:615) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4C8Oall.processError(T4C8Oall.java:1372) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:972) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:237) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4C8Oall.doOALL(T4C8Oall.java:524) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:298) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:1510) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OracleStatement.executeSQLStatement(OracleStatement.java:2020) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1633) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:3973) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OraclePreparedStatement.doExecuteLargeUpdate(OraclePreparedStatement.java:4339) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OraclePreparedStatement.executeLargeUpdate(OraclePreparedStatement.java:4316) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OraclePreparedStatement.executeUpdate(OraclePreparedStatement.java:4291) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OraclePreparedStatementWrapper.executeUpdate(OraclePreparedStatementWrapper.java:1007) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at com.zaxxer.hikari.pool.ProxyPreparedStatement.executeUpdate(ProxyPreparedStatement.java:61) ~[HikariCP-6.3.0.jar:na] at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.executeUpdate(HikariProxyPreparedStatement.java) ~[HikariCP-6.3.0.jar:na] at org.springframework.jdbc.core.JdbcTemplate.lambda$update$2(JdbcTemplate.java:977) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:658) ~[spring-jdbc-6.2.8.jar:6.2.8] ... 59 common frames omitted Caused by: oracle.jdbc.OracleDatabaseException: ORA-00923: FROM keyword not found where expected at oracle.jdbc.driver.T4CTTIoer11.processError(T4CTTIoer11.java:723) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] ... 77 common frames omitted package com.ing.datadist.api.repository; import com.ing.datadist.api.model.CreateInvolvedPartyResponseV5; import com.ing.datadist.api.model.InvolvedPartiesOrganisationUnitResponse; import com.ing.datadist.domain.OrganisationUnitDomainWrapper; import lombok.extern.slf4j.Slf4j; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import java.sql.Timestamp; import java.time.Instant; import java.time.LocalDate; @Repository @Slf4j public class AccountingDAO { private final JdbcTemplate jdbcTemplate; public AccountingDAO(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } /*   public void updateExternalIdentifier(String uuid, String externalId) { String sql = "UPDATE DD_ACCOUNT_TBL SET ORG_NUMBER = ?, UPDATED_TIME = ? WHERE DD_UUID = ?"; jdbcTemplate.update(sql, externalId, Timestamp.from(Instant.now()), uuid); log.info("Updated external ID for UUID={}", uuid); }*/ public void updateExternalIdentifier(String uuid, String externalId) { String sql = """ UPDATE DD_ACCOUNT_TBL SET ORG_NUMBER = ?, UPDATED_TIME = ? WHERE DD_UUID = ? """; jdbcTemplate.update(sql, externalId, Timestamp.from(Instant.now()), uuid); } /* public void updateOrganisationUnitName(String uuid, String organisationUnitName) { String sql = "UPDATE DD_ACCOUNT_TBL SET FIRST_NAME = ? WHERE DD_UUID = ?"; jdbcTemplate.update(sql, organisationUnitName, uuid); log.info(" Organisation unit name updated for UUID={}", uuid); } */ public void updateOrganisationUnitName(String uuid, String organisationUnitName) { String sql = """ UPDATE DD_ACCOUNT_TBL SET FIRST_NAME = ?, UPDATED_TIME = ? WHERE DD_UUID = ? """; jdbcTemplate.update(sql, organisationUnitName, Timestamp.from(Instant.now()), uuid); } /*public void updatePostalAddress(String uuid, String street, String houseNumber, String houseNumberAddition, String postalCode, String locality, String countryCode) { String sql = "UPDATE DD_ACCOUNT_TBL SET ADDR_STREET_NAME = ?, ADDR_HOUSE_NUMBER = ?, ADDR_BOX_NUMBER = ?, ADDR_POSTAL_CODE = ?, ADDR_LOCALITY_NAME = ?, ADDR_COUNTRY_CODE = ?, UPDATED_TIME = ? WHERE DD_UUID = ?"; jdbcTemplate.update(sql, street, houseNumber, houseNumberAddition, postalCode, locality, countryCode, Timestamp.from(Instant.now()), uuid); log.info("Postal Address updated for UUID={}", uuid); } */ public void updatePostalAddress(String uuid, String street, String houseNumber, String houseNumberAddition, String postalCode, String locality, String countryCode) { String sql = """ UPDATE DD_ACCOUNT_TBL SET ADDR_STREET_NAME = ?, ADDR_HOUSE_NUMBER = ?, ADDR_BOX_NUMBER = ?, ADDR_POSTAL_CODE = ?, ADDR_LOCALITY_NAME = ?, ADDR_COUNTRY_CODE = ?, UPDATED_TIME = ? WHERE DD_UUID = ? """; jdbcTemplate.update(sql, street, houseNumber, houseNumberAddition, postalCode, locality, countryCode, Timestamp.from(Instant.now()), uuid); } public void updateDigitalAddress(String uuid, String digitalAddress) { String sql = "UPDATE DD_ACCOUNT_TBL SET DIGITAL_ADDRESS = ?, UPDATED_TIME = ? WHERE DD_UUID = ?"; jdbcTemplate.update(sql, digitalAddress, Timestamp.from(Instant.now()), uuid); log.info("Digital Address updated for UUID={}", uuid); } public void updateHierarchy(String uuid, String parentId) { String sql = "UPDATE DD_ACCOUNT_TBL SET LAST_NAME = ?, UPDATED_TIME = ? WHERE DD_UUID = ?"; jdbcTemplate.update(sql, parentId, Timestamp.from(Instant.now()), uuid); log.info("Hierarchy updated for UUID={}", uuid); } public void createOuAccountingTableEntry(String ddUuid, String OuName) { String eventId = "null"; String sql = "INSERT INTO DD_ACCOUNT_TBL(DD_UUID,FIRST_NAME, EVENT_ID) VALUES (?,?,?)"; jdbcTemplate.update(sql, ddUuid, OuName, eventId); log.info("Created ou account table entry for UUID={}", ddUuid); } public void insertFullOrganisationUnit(CreateInvolvedPartyResponseV5 response) { InvolvedPartiesOrganisationUnitResponse orgUnit = response.getOrganisationUnit(); String ddUuid = orgUnit.getInvolvedPartyInternalIdentifiers().get(0).getInvolvedPartyInternalIdentifierValue(); String eventId = "null"; String typeOfEntity = "ORG_UNIT"; String orgName = orgUnit.getOrganisationUnitNames().get(0).getOrganisationUnitName(); Timestamp updatedTime = Timestamp.from(Instant.now()); String sql = "INSERT INTO DD_ACCOUNT_TBL (DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME, UPDATED_TIME) VALUES (?, ?, ?, ?, ?)"; jdbcTemplate.update(sql, ddUuid, eventId, typeOfEntity, orgName, updatedTime); log.info("Inserted organisation unit record: UUID={}, EVENT_ID={}, ORG_NAME={}", ddUuid, eventId, orgName); } /* public void insertFullOrganisationUnitWithWrapper(OrganisationUnitDomainWrapper wrapper) { String ddUuid = wrapper.getOpsUUID(); String eventId = "null"; String typeOfEntity = "ORG_UNIT"; String orgName = wrapper.getOrganisationUnitName(); String streetName = wrapper.getPostalAddressStreetNm(); String houseNumber = wrapper.getPostalAddressHouseNum(); String boxNumber = wrapper.getPostalAddressHouseNum(); String postalCode = wrapper.getPostalAddressPostalCd(); String countryCode = wrapper.getPostalAddressCntryCd(); String orgNumber = wrapper.getOrgExternalIdentifierVal(); String digitalAddress = wrapper.getDigitalAddrEmail(); Timestamp updatedTime = Timestamp.from(Instant.now()); String sql = "INSERT INTO DD_ACCOUNT_TBL (\n" + "DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME, ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER, ADDR_POSTAL_CODE," + " ADDR_COUNTRY_CODE, ORG_NUMBER, UPDATED_TIME, DIGITAL_ADDRESS) " + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"; jdbcTemplate.update(sql, ddUuid, eventId, typeOfEntity, orgName, streetName, houseNumber, boxNumber, postalCode, countryCode, orgNumber, updatedTime, digitalAddress); log.info("Inserted organisation unit record using wrapper UUID={}", ddUuid); } */ /* public void insertFullOrganisationUnitWithWrapper(OrganisationUnitDomainWrapper wrapper) { String ddUuid = wrapper.getOpsUUID(); String eventId = "null"; // Use SQL NULL String typeOfEntity = "ORG_UNIT"; String orgName = wrapper.getOrganisationUnitName(); String streetName = wrapper.getPostalAddressStreetNm(); String houseNumber = wrapper.getPostalAddressHouseNum(); String boxNumber = wrapper.getPostalAddressHouseAdd(); // FIXED String postalCode = wrapper.getPostalAddressPostalCd(); String locality = wrapper.getPostalAddressCityName(); // ADD locality String countryCode = wrapper.getPostalAddressCntryCd(); String orgNumber = wrapper.getOrgExternalIdentifierVal(); String digitalAddress = wrapper.getDigitalAddrEmail(); Timestamp updatedTime = Timestamp.from(Instant.now()); String sql = """ INSERT INTO DD_ACCOUNT_TBL ( DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME, ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER, ADDR_POSTAL_CODE, ADDR_LOCALITY_NAME, ADDR_COUNTRY_CODE, ORG_NUMBER, DIGITAL_ADDRESS, UPDATED_TIME ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) """; jdbcTemplate.update(sql, ddUuid, eventId, typeOfEntity, orgName, streetName, houseNumber, boxNumber, postalCode, locality, countryCode, orgNumber, digitalAddress, updatedTime); log.info("Inserted organisation unit record using wrapper UUID={}", ddUuid); } */ public void updatePostalAddressVerificationDate(String uuid, LocalDate verificationDate) { String sql = "UPDATE DD_ACCOUNT_TBL SET ADDR_LAST_VERIFICATION_DATE=?, UPDATED_TIME=? WHERE DD_UUID=?"; jdbcTemplate.update(sql, verificationDate, Timestamp.from(Instant.now()), uuid); log.info("Postal address verification date updated for UUID={}", uuid); } public void insertFullOrganisationUnitWithWrapper(OrganisationUnitDomainWrapper wrapper) { String ddUuid = wrapper.getOpsUUID(); String eventId = "null"; String typeOfEntity = "ORG_UNIT"; String orgName = wrapper.getOrganisationUnitName(); String streetName = wrapper.getPostalAddressStreetNm(); String houseNumber = wrapper.getPostalAddressHouseNum(); String boxNumber = wrapper.getPostalAddressHouseNum(); String postalCode = wrapper.getPostalAddressPostalCd(); String countryCode = wrapper.getPostalAddressCntryCd(); String orgNumber = wrapper.getOrgExternalIdentifierVal(); String digitalAddress = wrapper.getDigitalAddrEmail(); Timestamp updatedTime = Timestamp.from(Instant.now()); String sql = "INSERT INTO DD_ACCOUNT_TBL (\n" + "DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME, ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER, ADDR_POSTAL_CODE," + " ADDR_COUNTRY_CODE, ORG_NUMBER, UPDATED_TIME, DIGITAL_ADDRESS) " + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"; jdbcTemplate.update(sql, ddUuid, eventId, typeOfEntity, orgName, streetName, houseNumber, boxNumber, postalCode, countryCode, orgNumber, updatedTime, digitalAddress); log.info("Inserted organisation unit record using wrapper UUID={}", ddUuid); } public void insertFullOrganisationUnitWithWrapperMergeSqlServer(OrganisationUnitDomainWrapper wrapper) { log.info("AASTHA MERGE"); String ddUuid = wrapper.getOpsUUID(); String eventId = "null"; String typeOfEntity = "ORG_UNIT"; String orgName = wrapper.getOrganisationUnitName(); String streetName = wrapper.getPostalAddressStreetNm(); String houseNumber = wrapper.getPostalAddressHouseNum(); String boxNumber = wrapper.getPostalAddressHouseAdd(); String postalCode = wrapper.getPostalAddressPostalCd(); String locality   = wrapper.getPostalAddressCityName(); String countryCode = wrapper.getPostalAddressCntryCd(); String orgNumber = wrapper.getOrgExternalIdentifierVal(); String digitalAddress = wrapper.getDigitalAddrEmail(); Timestamp updatedTime = Timestamp.from(Instant.now()); log.info("AASTHA MERGE2"); String sql = """ MERGE INTO DD_ACCOUNT_TBL tgt USING ( SELECT ? AS DD_UUID, log.info("AASTHA MERGE3"); ? AS EVENT_ID, ? AS TYP_OF_ENTY, ? AS FIRST_NAME, ? AS ADDR_STREET_NAME, ? AS ADDR_HOUSE_NUMBER, ? AS ADDR_BOX_NUMBER, ? AS ADDR_POSTAL_CODE, ? AS ADDR_LOCALITY_NAME, ? AS ADDR_COUNTRY_CODE, ? AS ORG_NUMBER, ? AS DIGITAL_ADDRESS, ? AS UPDATED_TIME log.info("AASTHA MERGE4"); FROM dual ) src ON (tgt.DD_UUID = src.DD_UUID) WHEN MATCHED THEN UPDATE SET tgt.TYP_OF_ENTY        = src.TYP_OF_ENTY, tgt.FIRST_NAME         = src.FIRST_NAME, tgt.ADDR_STREET_NAME   = src.ADDR_STREET_NAME, tgt.ADDR_HOUSE_NUMBER  = src.ADDR_HOUSE_NUMBER, tgt.ADDR_BOX_NUMBER    = src.ADDR_BOX_NUMBER, tgt.ADDR_POSTAL_CODE   = src.ADDR_POSTAL_CODE, tgt.ADDR_LOCALITY_NAME = src.ADDR_LOCALITY_NAME, tgt.ADDR_COUNTRY_CODE  = src.ADDR_COUNTRY_CODE, tgt.ORG_NUMBER         = src.ORG_NUMBER, tgt.DIGITAL_ADDRESS    = src.DIGITAL_ADDRESS, tgt.UPDATED_TIME       = src.UPDATED_TIME log.info("AASTHA MERGE5"); WHEN NOT MATCHED THEN INSERT ( DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME, ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER, ADDR_POSTAL_CODE, ADDR_LOCALITY_NAME, ADDR_COUNTRY_CODE, ORG_NUMBER, DIGITAL_ADDRESS, UPDATED_TIME log.info("AASTHA MERGE6"); ) VALUES ( src.DD_UUID, src.EVENT_ID, src.TYP_OF_ENTY, src.FIRST_NAME, src.ADDR_STREET_NAME, src.ADDR_HOUSE_NUMBER, src.ADDR_BOX_NUMBER, src.ADDR_POSTAL_CODE, src.ADDR_LOCALITY_NAME, src.ADDR_COUNTRY_CODE, src.ORG_NUMBER, src.DIGITAL_ADDRESS, src.UPDATED_TIME ) """; log.info("AASTHA MERGE7"); jdbcTemplate.update(sql, ddUuid, eventId, typeOfEntity, orgName, streetName, houseNumber, boxNumber, postalCode, locality, countryCode, orgNumber, digitalAddress, updatedTime); log.info("Upserted organisation unit record using wrapper (SQL Server MERGE) UUID={}", ddUuid); } } //a8eb7b57-9780-41b8-a552-3b2388ebeaad // package com.ing.datadist.api.service; import com.ing.datadist.api.model.*; import com.ing.datadist.api.repository.AccountingDAO; import com.ing.datadist.batch.repository.MappingDAO; import com.ing.datadist.configreader.CofaceOpsConfigReader; import com.ing.datadist.domain.OrganisationUnitDomainWrapper; import com.ing.datadist.kafka.util.EventTransactionType; import com.ing.datadist.kafka.util.NotificationStatus; import com.twitter.finagle.http.Response; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; import java.time.Instant; import java.time.ZonedDateTime; import java.time.format.DateTimeFormatter; import java.time.temporal.ChronoUnit; import java.util.*; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import static com.ing.datadist.api.utils.DataDistributionConstants.*; @Service @Slf4j public class OrganisationUnitService { private final OnePamRepository onePamRepository; private final CofaceOpsConfigReader configReader; private final AddressService addressService; private final DigitalAddrService digitalAddrService; private final AccountingDAO accountingDAO; private final MappingDAO mappingDAO; Instant effectiveDateSet = Instant.now() .minusSeconds(120) // safety margin .truncatedTo(ChronoUnit.SECONDS); Instant endDateSet = effectiveDateSet.plus(3652, ChronoUnit.DAYS); private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("dd-MM-yyyy"); public OrganisationUnitService(OnePamRepository onePamRepository, CofaceOpsConfigReader configReader, AddressService addressService, DigitalAddrService digitalAddrService, AccountingDAO accountingDAO, MappingDAO mappingDAO) { this.onePamRepository = onePamRepository; this.configReader = configReader; this.addressService = addressService; this.digitalAddrService = digitalAddrService; this.accountingDAO = accountingDAO; this.mappingDAO = mappingDAO; } public void processOrganisationUnit(String orgNumber) throws Exception { CreatePostalAddressRequest postalRequest = new CreatePostalAddressRequest(); CreateDigitalAddressV5Request digitalRequest = new CreateDigitalAddressV5Request("", "", "", ""); UpdateExternalIdentifierOrganisationUnitRequest externalIdRequest = new UpdateExternalIdentifierOrganisationUnitRequest(); CreateOrganisationUnitRequest orgUnitRequest = new CreateOrganisationUnitRequest(); processOrganisationUnit(orgNumber, postalRequest, digitalRequest, externalIdRequest, orgUnitRequest); } public void processOrganisationUnit(String orgNumber, CreatePostalAddressRequest postalRequest, CreateDigitalAddressV5Request digitalRequest, UpdateExternalIdentifierOrganisationUnitRequest externalIdRequest, CreateOrganisationUnitRequest orgUnitRequest) throws ExecutionException, InterruptedException { // 1. Fetch config Map<String, String> config = getConfig("2355630548"); log.info("AASTHA CONFIG"+ orgNumber); // 2. Build wrapper for local DB insert OrganisationUnitDomainWrapper wrapper = new OrganisationUnitDomainWrapper(); wrapper.setOpsUUID(config.get("OPS_UUID")); wrapper.setOrgExternalIdentifierVal(config.get("orgNumber")); log.info("AASTHA DOMAIN CONFIG"+ config.get("orgNumber")); wrapper.setOrganisationUnitName(decodeHtml(config.get("organisationUnitName"))); log.info("AASTHA ORG NNUMBER " + config.get("organisationUnitName")); wrapper.setPostalAddressStreetNm(config.get("streetName")); log.info("AASTHA ORG NNUMBER " + config.get("streetName")); wrapper.setPostalAddressHouseNum(config.get("ADR_POSTALADDRESS_HOUSENUM")); wrapper.setPostalAddressHouseAdd(config.get("ADR_POSTALADDRESS_HOUSEADD")); wrapper.setPostalAddressPostalCd(config.get("ADR_POSTALADDRESS_POSTALCD")); wrapper.setPostalAddressCityName(config.get("ADR_POSTALADDRESS_CITYNAME")); wrapper.setPostalAddressCntryCd(normalizeCountryCode(config.get("ADR_POSTALADDRESS_CNTRYCD"))); wrapper.setOpsExtIdDateOfIssue(config.get("OPS_EXTID_DATEOFISSUE")); wrapper.setOpsExtIdExpiryDate(config.get("OPS_EXTID_EXPIRYDATE")); wrapper.setDigitalAddrEmail(config.get("ADR_DIGITALADDR_EMAIL")); // 3. Insert into SQL (MERGE) accountingDAO.insertFullOrganisationUnitWithWrapperMergeSqlServer(wrapper); // 4. Create OU using OnePam CreateInvolvedPartyResponseV5 response = createOrganisationUnit(orgNumber); // Extract UUID String uuid = response.getOrganisationUnit() .getInvolvedPartyInternalIdentifiers() .stream() .findFirst() .map(InternalIdentifierResponse::getInvolvedPartyInternalIdentifierValue) .orElse(null); if (uuid == null || uuid.isBlank()) { return; // Stop if UUID not returned } // 5. Update External Identifier (Sequential) UpdateExternalIdentifierOrganisationUnitRequest updateRequest = buildUpdateRequest(uuid); onePamRepository.updateExternalIdentifier(uuid, updateRequest).get(); accountingDAO.updateExternalIdentifier(uuid, updateRequest.getInvolvedPartyExternalIdentifierValue()); // 6. Create Postal Address (Sequential) PostalAddressResponse addr = addressService.createPostalAddress(uuid); if (addr != null) { accountingDAO.updatePostalAddress(uuid, addr.getStreetName(), addr.getHouseNumber(), addr.getHouseNumberAddition(), addr.getPostalCode(), addr.getCityName(), addr.getCountryCode()); } // 7. Digital Address (Optional) // digitalAddrService.createDigitalAddress(uuid, digitalRequest); String finalUuid3 = uuid; final String parentId = "a8eb7b57-9780-41b8-a552-3b2388ebeaad"; // Replace with real parent UUID after LE created if (parentId != null && !parentId.isEmpty()) { //    try { accountingDAO.updateHierarchy(uuid, parentId); mappingDAO.insertEventTrack(uuid, "OrganisationUnitHierarchyAPI", EventTransactionType.CREATE_ORG_HIERARCHY.getLabel(), NotificationStatus.PENDING.name()); Response response1 = createOrganisationUnitHierarchy(uuid, parentId); //   if (response1.statusCode() >= 200 && response1.statusCode() < 300) { mappingDAO.insertEventTrack(uuid, "OrganisationUnitHierarchyAPI", EventTransactionType.CREATE_ORG_HIERARCHY.getLabel(), NotificationStatus.RECEIVED.name()); //                } //            } catch (Exception e) { //                log.error("Hierarchy creation failed for UUID={} : {}", uuid, e.getMessage(), e); //            } } else { log.info("No parent UUID present for {}", uuid); } } private CreateInvolvedPartyResponseV5 createOrganisationUnit(String uuid) { String organisationUnitName = String.valueOf(configReader.fetchOrganisationUnitName(uuid)); Map<String, String> config = getConfig(uuid); CreateInvolvedPartyRequestV5 request = CreateInvolvedPartyRequestV5.builder() .organisationUnit( CreateOrganisationUnitRequest.builder() .dataSource(DATA_SOURCE) .logicalDataDomain(LOGICAL_DATA_DOMAIN) .countryOfResidence(config.get("countryOfResidence")) .preferredLanguage(LANGUAGE) .channelOfEntry(CHANNEL_OF_ENTRY) .organisationUnitStructureType(STRUCTURE_TYPE) .effectiveDate(config.get("dateOfIssue")) .involvedPartyInternalIdentifiers(Collections.singletonList( CreateInternalIdentifierRequest.builder() .involvedPartyInternalIdentifierType("CSI_BE") .involvedPartyInternalIdentifierValue(config.get(uuid)) .build())) .organisationUnitNames(Collections.singletonList( CreateOrganisationUnitNameRequest.builder() .organisationUnitNameType(ORGANISATION_UNIT_NAME_TYPE) .organisationUnitName(organisationUnitName) .build())) .build()) .build(); try { accountingDAO.createOuAccountingTableEntry(uuid,organisationUnitName); mappingDAO.insertEventTrack(uuid, "CreateOrganisationUnitApi", EventTransactionType.CREATE_ORG_UNIT.getLabel(), NotificationStatus.PENDING.name()); CreateInvolvedPartyResponseV5 responseV5 = onePamRepository.createInvolvedParty(request).get(); mappingDAO.insertEventTrack(uuid, "CreateOrganisationUnitApi", EventTransactionType.CREATE_ORG_UNIT.getLabel(), NotificationStatus.RECEIVED.name()); if( mappingDAO.findPendingNotifications(uuid).isEmpty()) { mappingDAO.insertFinalStatus(uuid, "SUCCESS"); log.info(" FINAL STATUS INSERTED for {}", uuid); } return responseV5; } catch (Exception e) { log.error("Failed to create organisation unit for uuid={}: {}", uuid, e.getMessage(), e); throw new RuntimeException(e); } } private UpdateExternalIdentifierOrganisationUnitRequest buildUpdateRequest(String uuid) { Map<String, String> config = getConfig(uuid); return UpdateExternalIdentifierOrganisationUnitRequest.builder() .involvedPartyExternalIdentifierType(EXTERNAL_ID_TYPE) .involvedPartyExternalIdentifierValue(config.getOrDefault("ORG_NUMBER", uuid)) .countryOfIssue(config.get("countryOfResidence")) .placeOfIssue(PLACE_OF_ISSUE) .dateOfIssue(config.get("dateOfIssue")) .expiryDate(config.get("expiryDate")) .dataSource(DATA_SOURCE) .effectiveDate(effectiveDateSet.toString()) .endDate(endDateSet.toString()) .build(); } //    private Response createOrganisationUnitHierarchy(String childId, String parentId) { //        OrganisationUnitOrganisationRelationshipRequest request = OrganisationUnitOrganisationRelationshipRequest.builder() //                .childOrganisationUnitIdentifier(childId) //                .parentOrganisationIdentifier(parentId) //             //   .parentRoleReasonType(ROLE_REASON_TYPE) //                .dataSource(DATA_SOURCE) //                .build(); //        try { //            Response response = onePamRepository.createOrganisationUnitHierarchy(request).get(); //            log.info("Successfully created hierarchy between child: {} and parent: {}", childId, parentId); //            return response; //        } catch (Exception e) { //            log.error("Failed to create organisation unit hierarchy", e); //            throw new RuntimeException("Hierarchy creation failed", e); //        } //    } private Response createOrganisationUnitHierarchy(String childId, String parentId) { OrganisationUnitOrganisationRelationshipRequest relationshipRequest = OrganisationUnitOrganisationRelationshipRequest.builder() .childOrganisationUnitIdentifier(childId) .parentOrganisationIdentifier(parentId) .parentRoleReasonType("CPTL_CTRL") // Replace with constant if needed .dataSource("FOS_IT") // Replace with constant if needed .build(); OrganisationUnitOrganisationRelationshipRequestV1 wrapper = OrganisationUnitOrganisationRelationshipRequestV1.builder() .organisationUnitOrganisationRelationship(relationshipRequest) .build(); try { Response response = onePamRepository.createOrganisationUnitHierarchy(wrapper).get(); log.info("Successfully created hierarchy between child: {} and parent: {}", childId, parentId); return response; } catch (Exception e) { log.error("Failed to create organisation unit hierarchy", e); throw new RuntimeException("Hierarchy creation failed", e); } } private Map<String, String> getConfig(String orgNumber) { try{ List<Map<String, String>> list = configReader.fetchByOrgNumber(orgNumber); return list.isEmpty() ? Collections.emptyMap() : list.get(0); } catch (Exception e){ e.printStackTrace(); throw e; } } private String decodeHtml(String s) { return (s == null) ? null : s.replace("&amp;", "&").trim(); } private String normalizeCountryCode(String s) { if (s == null || s.isBlank()) return null; return "000".equals(s.trim()) ? "BE" : s.trim().toUpperCase(); } }
