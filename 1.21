manager: DHOKALE, A. (Aastha), need to update this OPS_NUMBER not fetch by ORG_NUMBER everywhere as well, this logic only wrong error log: 2025-12-03T10:33:03.302+05:30 DEBUG 42356 --- [Integration-Module] [   scheduling-1] c.i.d.c.CofaceOpsConfigReader            : End of fetchByOrgNumber 2025-12-03T10:33:03.302+05:30  INFO 42356 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : CONFIG LOADED FOR ORG=9aa1ae44-f2f4-47a1-9266-f7053476a9a6 -> {} 2025-12-03T10:33:03.303+05:30  INFO 42356 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA UUID9aa1ae44-f2f4-47a1-9266-f7053476a9a6 2025-12-03T10:33:03.303+05:30  INFO 42356 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA UUID WRAPPERnull 2025-12-03T10:33:03.303+05:30  INFO 42356 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA ORG_NUMBER null 2025-12-03T10:33:03.303+05:30  INFO 42356 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA ORG NAMEnull 2025-12-03T10:33:03.303+05:30  INFO 42356 --- [Integration-Module] [   scheduling-1] c.i.d.a.service.OrganisationUnitService  : AASTHA STREET NAMEnull 2025-12-03T10:33:03.303+05:30  INFO 42356 --- [Integration-Module] [   scheduling-1] c.i.d.api.repository.AccountingDAO       : AASTHA MERGE 2025-12-03T10:33:03.303+05:30  INFO 42356 --- [Integration-Module] [   scheduling-1] c.i.d.api.repository.AccountingDAO       : AASTHA MERGE2 2025-12-03T10:33:03.304+05:30  INFO 42356 --- [Integration-Module] [   scheduling-1] c.i.d.api.repository.AccountingDAO       : AASTHA MERGE7 2025-12-03T10:33:03.325+05:30 ERROR 42356 --- [Integration-Module] [   scheduling-1] c.i.d.b.tasklet.OnePamSearchApiTasklet   : Exception occurred while executing API call for UUID :9aa1ae44-f2f4-47a1-9266-f7053476a9a6 error :{} org.springframework.dao.DataIntegrityViolationException: PreparedStatementCallback; SQL [MERGE INTO DD_ACCOUNT_TBL tgt USING ( SELECT ? AS DD_UUID, ? AS EVENT_ID, ? AS TYP_OF_ENTY, ? AS FIRST_NAME, ? AS ADDR_STREET_NAME, ? AS ADDR_HOUSE_NUMBER, ? AS ADDR_BOX_NUMBER, ? AS ADDR_POSTAL_CODE, ? AS ADDR_LOCALITY_NAME, ? AS ADDR_COUNTRY_CODE, ? AS ORG_NUMBER, ? AS DIGITAL_ADDRESS, ? AS UPDATED_TIME FROM dual ) src ON (tgt.DD_UUID = src.DD_UUID) WHEN MATCHED THEN UPDATE SET tgt.TYP_OF_ENTY        = src.TYP_OF_ENTY, tgt.FIRST_NAME         = src.FIRST_NAME, tgt.ADDR_STREET_NAME   = src.ADDR_STREET_NAME, tgt.ADDR_HOUSE_NUMBER  = src.ADDR_HOUSE_NUMBER, tgt.ADDR_BOX_NUMBER    = src.ADDR_BOX_NUMBER, tgt.ADDR_POSTAL_CODE   = src.ADDR_POSTAL_CODE, tgt.ADDR_LOCALITY_NAME = src.ADDR_LOCALITY_NAME, tgt.ADDR_COUNTRY_CODE  = src.ADDR_COUNTRY_CODE, tgt.ORG_NUMBER         = src.ORG_NUMBER, tgt.DIGITAL_ADDRESS    = src.DIGITAL_ADDRESS, tgt.UPDATED_TIME       = src.UPDATED_TIME WHEN NOT MATCHED THEN INSERT ( DD_UUID, EVENT_ID, TYP_OF_ENTY, FIRST_NAME, ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER, ADDR_POSTAL_CODE, ADDR_LOCALITY_NAME, ADDR_COUNTRY_CODE, ORG_NUMBER, DIGITAL_ADDRESS, UPDATED_TIME ) VALUES ( src.DD_UUID, src.EVENT_ID, src.TYP_OF_ENTY, src.FIRST_NAME, src.ADDR_STREET_NAME, src.ADDR_HOUSE_NUMBER, src.ADDR_BOX_NUMBER, src.ADDR_POSTAL_CODE, src.ADDR_LOCALITY_NAME, src.ADDR_COUNTRY_CODE, src.ORG_NUMBER, src.DIGITAL_ADDRESS, src.UPDATED_TIME ) ]; ORA-01400: cannot insert NULL into ("SYSTEM"."DD_ACCOUNT_TBL"."DD_UUID") https://docs.oracle.com/error-help/db/ora-01400/ at org.springframework.jdbc.support.SQLExceptionSubclassTranslator.doTranslate(SQLExceptionSubclassTranslator.java:97) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:107) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.translateException(JdbcTemplate.java:1556) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:677) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:972) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:1016) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:1026) ~[spring-jdbc-6.2.8.jar:6.2.8] at com.ing.datadist.api.repository.AccountingDAO.insertFullOrganisationUnitWithWrapperMergeSqlServer(AccountingDAO.java:325) ~[classes/:na] at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na] at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na] at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:138) ~[spring-tx-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:728) ~[spring-aop-6.2.8.jar:6.2.8] at com.ing.datadist.api.repository.AccountingDAO$$SpringCGLIB$$0.insertFullOrganisationUnitWithWrapperMergeSqlServer(<generated>) ~[classes/:na] at com.ing.datadist.api.service.OrganisationUnitService.processOrganisationUnit(OrganisationUnitService.java:334) ~[classes/:na] at com.ing.datadist.batch.tasklet.OnePamSearchApiTasklet.execute(OnePamSearchApiTasklet.java:76) ~[classes/:na] at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na] at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na] at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:137) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:124) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184) ~[spring-aop-6.2.8.jar:6.2.8] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:728) ~[spring-aop-6.2.8.jar:6.2.8] at com.ing.datadist.batch.tasklet.OnePamSearchApiTasklet$$SpringCGLIB$$0.execute(<generated>) ~[classes/:na] at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:383) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:307) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:140) ~[spring-tx-6.2.8.jar:6.2.8] at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:250) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:82) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.repeat.support.RepeatTemplate.getNextResult(RepeatTemplate.java:369) ~[spring-batch-infrastructure-5.2.2.jar:5.2.2] at org.springframework.batch.repeat.support.RepeatTemplate.executeInternal(RepeatTemplate.java:206) ~[spring-batch-infrastructure-5.2.2.jar:5.2.2] at org.springframework.batch.repeat.support.RepeatTemplate.iterate(RepeatTemplate.java:140) ~[spring-batch-infrastructure-5.2.2.jar:5.2.2] at org.springframework.batch.core.step.tasklet.TaskletStep.doExecute(TaskletStep.java:235) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:230) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:153) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.job.AbstractJob.handleStep(AbstractJob.java:408) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.job.SimpleJob.doExecute(SimpleJob.java:127) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:307) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher$1.run(TaskExecutorJobLauncher.java:155) ~[spring-batch-core-5.2.2.jar:5.2.2] at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:50) ~[spring-core-6.2.8.jar:6.2.8] at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher.run(TaskExecutorJobLauncher.java:146) ~[spring-batch-core-5.2.2.jar:5.2.2] at com.ing.datadist.batch.schedular.BatchSchedular.run(BatchSchedular.java:50) ~[classes/:na] at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na] at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na] at org.springframework.scheduling.support.ScheduledMethodRunnable.runInternal(ScheduledMethodRunnable.java:130) ~[spring-context-6.2.8.jar:6.2.8] at org.springframework.scheduling.support.ScheduledMethodRunnable.lambda$run$2(ScheduledMethodRunnable.java:124) ~[spring-context-6.2.8.jar:6.2.8] at io.micrometer.observation.Observation.observe(Observation.java:498) ~[micrometer-observation-1.15.1.jar:1.15.1] at org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:124) ~[spring-context-6.2.8.jar:6.2.8] at org.springframework.scheduling.config.Task$OutcomeTrackingRunnable.run(Task.java:85) ~[spring-context-6.2.8.jar:6.2.8] at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) ~[spring-context-6.2.8.jar:6.2.8] at org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:96) ~[spring-context-6.2.8.jar:6.2.8] at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572) ~[na:na] at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317) ~[na:na] at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) ~[na:na] at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144) ~[na:na] at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642) ~[na:na] at java.base/java.lang.Thread.run(Thread.java:1583) ~[na:na] Caused by: java.sql.SQLIntegrityConstraintViolationException: ORA-01400: cannot insert NULL into ("SYSTEM"."DD_ACCOUNT_TBL"."DD_UUID") https://docs.oracle.com/error-help/db/ora-01400/ at oracle.jdbc.driver.T4CTTIoer11.processError(T4CTTIoer11.java:715) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4CTTIoer11.processError(T4CTTIoer11.java:615) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4C8Oall.processError(T4C8Oall.java:1372) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:972) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:237) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4C8Oall.doOALL(T4C8Oall.java:524) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:298) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:1510) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OracleStatement.executeSQLStatement(OracleStatement.java:2020) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1633) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:3973) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OraclePreparedStatement.doExecuteLargeUpdate(OraclePreparedStatement.java:4339) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OraclePreparedStatement.executeLargeUpdate(OraclePreparedStatement.java:4316) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OraclePreparedStatement.executeUpdate(OraclePreparedStatement.java:4291) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at oracle.jdbc.driver.OraclePreparedStatementWrapper.executeUpdate(OraclePreparedStatementWrapper.java:1007) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] at com.zaxxer.hikari.pool.ProxyPreparedStatement.executeUpdate(ProxyPreparedStatement.java:61) ~[HikariCP-6.3.0.jar:na] at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.executeUpdate(HikariProxyPreparedStatement.java) ~[HikariCP-6.3.0.jar:na] at org.springframework.jdbc.core.JdbcTemplate.lambda$update$2(JdbcTemplate.java:977) ~[spring-jdbc-6.2.8.jar:6.2.8] at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:658) ~[spring-jdbc-6.2.8.jar:6.2.8] ... 58 common frames omitted Caused by: oracle.jdbc.OracleDatabaseException: ORA-01400: cannot insert NULL into ("SYSTEM"."DD_ACCOUNT_TBL"."DD_UUID") at oracle.jdbc.driver.T4CTTIoer11.processError(T4CTTIoer11.java:723) ~[ojdbc17-23.8.0.25.04.jar:23.8.0.25.04] ... 76 common frames omitted package com.ing.datadist.api.service; import com.ing.datadist.api.model.*; import com.ing.datadist.api.repository.AccountingDAO; import com.ing.datadist.batch.repository.MappingDAO; import com.ing.datadist.configreader.CofaceOpsConfigReader; import com.ing.datadist.domain.OrganisationUnitDomainWrapper; import com.ing.datadist.kafka.util.EventTransactionType; import com.ing.datadist.kafka.util.NotificationStatus; import com.twitter.finagle.http.Response; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; import java.time.Instant; import java.time.ZonedDateTime; import java.time.format.DateTimeFormatter; import java.time.temporal.ChronoUnit; import java.util.*; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import static com.ing.datadist.api.utils.DataDistributionConstants.*; @Service @Slf4j public class OrganisationUnitService { private final OnePamRepository onePamRepository; private final CofaceOpsConfigReader configReader; private final AddressService addressService; private final DigitalAddrService digitalAddrService; private final AccountingDAO accountingDAO; private final MappingDAO mappingDAO; Instant effectiveDateSet = Instant.now() .minusSeconds(120) // safety margin .truncatedTo(ChronoUnit.SECONDS); Instant endDateSet = effectiveDateSet.plus(3652, ChronoUnit.DAYS); private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("dd-MM-yyyy"); public OrganisationUnitService(OnePamRepository onePamRepository, CofaceOpsConfigReader configReader, AddressService addressService, DigitalAddrService digitalAddrService, AccountingDAO accountingDAO, MappingDAO mappingDAO) { this.onePamRepository = onePamRepository; this.configReader = configReader; this.addressService = addressService; this.digitalAddrService = digitalAddrService; this.accountingDAO = accountingDAO; this.mappingDAO = mappingDAO; } public void processOrganisationUnit(String orgNumber                                    ) throws Exception { // 1. FETCH CONFIG Map<String, String> config = getConfig(orgNumber); log.info("CONFIG LOADED FOR ORG={} -> {}", orgNumber, config); // 2. BUILD WRAPPER (MERGE INTO SQL) OrganisationUnitDomainWrapper wrapper = new OrganisationUnitDomainWrapper(); log.info("AASTHA UUID" + orgNumber); log.info("AASTHA UUID WRAPPER" + wrapper.getOpsUUID()); wrapper.setOpsUUID(config.get("orgNumber")); wrapper.setOrgExternalIdentifierVal(config.get("orgNumber")); log.info("AASTHA ORG_NUMBER " + config.get("orgNumber")); wrapper.setOrganisationUnitName(decodeHtml(config.get("organisationUnitName"))); log.info("AASTHA ORG NAME" + config.get("organisationUnitName")); wrapper.setPostalAddressStreetNm(config.get("ADR_POSTALADDRESS_STREETNM")); log.info("AASTHA STREET NAME" + config.get("streetName")); wrapper.setPostalAddressHouseNum(config.get("ADR_POSTALADDRESS_HOUSENUM")); wrapper.setPostalAddressHouseAdd(config.get("ADR_POSTALADDRESS_HOUSEADD")); wrapper.setPostalAddressPostalCd(config.get("ADR_POSTALADDRESS_POSTALCD")); wrapper.setPostalAddressCityName(config.get("ADR_POSTALADDRESS_CITYNAME")); wrapper.setPostalAddressCntryCd(normalizeCountryCode(config.get("ADR_POSTALADDRESS_CNTRYCD"))); wrapper.setOpsExtIdDateOfIssue(config.get("OPS_EXTID_DATEOFISSUE")); wrapper.setOpsExtIdExpiryDate(config.get("OPS_EXTID_EXPIRYDATE")); wrapper.setDigitalAddrEmail(config.get("ADR_DIGITALADDR_EMAIL")); accountingDAO.insertFullOrganisationUnitWithWrapperMergeSqlServer(wrapper); // 3. CREATE OU CreateInvolvedPartyResponseV5 response = createOrganisationUnit(orgNumber); // 4. EXTRACT UUID SAFELY String uuid = response.getOrganisationUnit() .getInvolvedPartyInternalIdentifiers() .stream() .findFirst() .map(InternalIdentifierResponse::getInvolvedPartyInternalIdentifierValue) .orElse(null); if (uuid == null || uuid.isBlank()) { log.error("NO UUID returned for ORG={}. Stopping flow.", orgNumber); return; } log.info("UUID extracted for ORG {} => {}", orgNumber, uuid); // 5. UPDATE EXTERNAL IDENTIFIER (SEQUENTIAL) UpdateExternalIdentifierOrganisationUnitRequest updateRequest = UpdateExternalIdentifierOrganisationUnitRequest.builder() .involvedPartyExternalIdentifierType(EXTERNAL_ID_TYPE) .involvedPartyExternalIdentifierValue(config.get("ORG_NUMBER")) .build(); Response extIdResp = onePamRepository.updateExternalIdentifier(uuid, updateRequest).get(); if (extIdResp.statusCode() >= 200 && extIdResp.statusCode() < 300) { accountingDAO.updateExternalIdentifier(uuid, config.get("ORG_NUMBER")); } else { log.error("External ID update FAILED for UUID={} status={}", uuid, extIdResp.statusCode()); return; } // 6. CREATE POSTAL ADDRESS (SEQUENTIAL) PostalAddressResponse addr = addressService.createPostalAddress(uuid); if (addr != null) { accountingDAO.updatePostalAddress( uuid, addr.getStreetName(), addr.getHouseNumber(), addr.getHouseNumberAddition(), addr.getPostalCode(), addr.getCityName(), addr.getCountryCode() ); } // //    // 7. OPTIONAL DIGITAL ADDRESS //    if (digitalRequest != null && digitalRequest.getFullDigitalAddress() != null) { //        DigitalAddressResponse dar = digitalAddrService.createDigitalAddress(uuid, digitalRequest); //        if (dar != null) { //            accountingDAO.updateDigitalAddress(uuid, dar.getFullDigitalAddress()); //        } //    } // 8. HIERARCHY CREATION (SEQUENTIAL) final String parentId = "a8eb7b57-9780-41b8-a552-3b2388ebeaad"; accountingDAO.updateHierarchy(uuid, parentId); mappingDAO.insertEventTrack(uuid, "OrganisationUnitHierarchyAPI", EventTransactionType.CREATE_ORG_HIERARCHY.getLabel(), NotificationStatus.PENDING.name()); Response hierResp = createOrganisationUnitHierarchy(uuid, parentId); mappingDAO.insertEventTrack(uuid, "OrganisationUnitHierarchyAPI", EventTransactionType.CREATE_ORG_HIERARCHY.getLabel(), NotificationStatus.RECEIVED.name()); log.info("SEQUENTIAL FLOW COMPLETE for UUID={}", uuid); } private CreateInvolvedPartyResponseV5 createOrganisationUnit(String uuid) { String organisationUnitName = String.valueOf(configReader.fetchOrganisationUnitName(uuid)); Map<String, String> config = getConfig(uuid); CreateInvolvedPartyRequestV5 request = CreateInvolvedPartyRequestV5.builder() .organisationUnit( CreateOrganisationUnitRequest.builder() .dataSource(DATA_SOURCE) .logicalDataDomain(LOGICAL_DATA_DOMAIN) .countryOfResidence(config.get("countryOfResidence")) .preferredLanguage(LANGUAGE) .channelOfEntry(CHANNEL_OF_ENTRY) .organisationUnitStructureType(STRUCTURE_TYPE) .effectiveDate(config.get("dateOfIssue")) .involvedPartyInternalIdentifiers(Collections.singletonList( CreateInternalIdentifierRequest.builder() .involvedPartyInternalIdentifierType("CSI_BE") .involvedPartyInternalIdentifierValue(config.get(uuid)) .build())) .organisationUnitNames(Collections.singletonList( CreateOrganisationUnitNameRequest.builder() .organisationUnitNameType(ORGANISATION_UNIT_NAME_TYPE) .organisationUnitName(organisationUnitName) .build())) .build()) .build(); try { accountingDAO.createOuAccountingTableEntry(uuid,organisationUnitName); mappingDAO.insertEventTrack(uuid, "CreateOrganisationUnitApi", EventTransactionType.CREATE_ORG_UNIT.getLabel(), NotificationStatus.PENDING.name()); CreateInvolvedPartyResponseV5 responseV5 = onePamRepository.createInvolvedParty(request).get(); mappingDAO.insertEventTrack(uuid, "CreateOrganisationUnitApi", EventTransactionType.CREATE_ORG_UNIT.getLabel(), NotificationStatus.RECEIVED.name()); if( mappingDAO.findPendingNotifications(uuid).isEmpty()) { mappingDAO.insertFinalStatus(uuid, "SUCCESS"); log.info(" FINAL STATUS INSERTED for {}", uuid); } return responseV5; } catch (Exception e) { log.error("Failed to create organisation unit for uuid={}: {}", uuid, e.getMessage(), e); throw new RuntimeException(e); } } private UpdateExternalIdentifierOrganisationUnitRequest buildUpdateRequest(String uuid) { Map<String, String> config = getConfig(uuid); return UpdateExternalIdentifierOrganisationUnitRequest.builder() .involvedPartyExternalIdentifierType(EXTERNAL_ID_TYPE) .involvedPartyExternalIdentifierValue(config.getOrDefault("ORG_NUMBER", uuid)) .countryOfIssue(config.get("countryOfResidence")) .placeOfIssue(PLACE_OF_ISSUE) .dateOfIssue(config.get("dateOfIssue")) .expiryDate(config.get("expiryDate")) .dataSource(DATA_SOURCE) .effectiveDate(effectiveDateSet.toString()) .endDate(endDateSet.toString()) .build(); } //    private Response createOrganisationUnitHierarchy(String childId, String parentId) { //        OrganisationUnitOrganisationRelationshipRequest request = OrganisationUnitOrganisationRelationshipRequest.builder() //                .childOrganisationUnitIdentifier(childId) //                .parentOrganisationIdentifier(parentId) //             //   .parentRoleReasonType(ROLE_REASON_TYPE) //                .dataSource(DATA_SOURCE) //                .build(); //        try { //            Response response = onePamRepository.createOrganisationUnitHierarchy(request).get(); //            log.info("Successfully created hierarchy between child: {} and parent: {}", childId, parentId); //            return response; //        } catch (Exception e) { //            log.error("Failed to create organisation unit hierarchy", e); //            throw new RuntimeException("Hierarchy creation failed", e); //        } //    } private Response createOrganisationUnitHierarchy(String childId, String parentId) { OrganisationUnitOrganisationRelationshipRequest relationshipRequest = OrganisationUnitOrganisationRelationshipRequest.builder() .childOrganisationUnitIdentifier(childId) .parentOrganisationIdentifier(parentId) .parentRoleReasonType("CPTL_CTRL") // Replace with constant if needed .dataSource("FOS_IT") // Replace with constant if needed .build(); OrganisationUnitOrganisationRelationshipRequestV1 wrapper = OrganisationUnitOrganisationRelationshipRequestV1.builder() .organisationUnitOrganisationRelationship(relationshipRequest) .build(); try { Response response = onePamRepository.createOrganisationUnitHierarchy(wrapper).get(); log.info("Successfully created hierarchy between child: {} and parent: {}", childId, parentId); return response; } catch (Exception e) { log.error("Failed to create organisation unit hierarchy", e); throw new RuntimeException("Hierarchy creation failed", e); } } private Map<String, String> getConfig(String orgNumber) { try{ List<Map<String, String>> list = configReader.fetchByOrgNumber(orgNumber); return list.isEmpty() ? Collections.emptyMap() : list.get(0); } catch (Exception e){ e.printStackTrace(); throw e; } } private String decodeHtml(String s) { return (s == null) ? null : s.replace("&amp;", "&").trim(); } private String normalizeCountryCode(String s) { if (s == null || s.isBlank()) return null; return "000".equals(s.trim()) ? "BE" : s.trim().toUpperCase(); } } package com.ing.datadist.configreader; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import java.util.HashMap; import java.util.List; import java.util.Map; @Repository @Slf4j public class CofaceOpsConfigReader { private static final String FETCH_BY_ORG_NUMBER_SQL = "SELECT OPS_ORGANISATIONUNITNAME, ORG_NUMBER, ADR_POSTALADDRESS_CNTRYCD, " + "ADR_POSTALADDRESS_STREETNM, ADR_POSTALADDRESS_HOUSENUM, ADR_POSTALADDRESS_HOUSEADD, " + "ADR_POSTALADDRESS_POSTALCD, ADR_POSTALADDRESS_CITYNAME, " + "OPS_EXTID_DATEOFISSUE, OPS_EXTID_EXPIRYDATE, " + "ADR_DIGITALADDR_EMAIL " + "FROM DD_COFACEOPS_TBL WHERE OPS_NUMBER = ?"; private final JdbcTemplate jdbcTemplate; @Autowired public CofaceOpsConfigReader(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } public List<Map<String, String>> fetchByOrgNumber(String OPS_NUMBER) { try{ log.debug("Start of fetchByOrgNumber"); log.debug("Fetching organisation unit config for Org Number: '{}'", OPS_NUMBER); List<Map<String, String>> results = jdbcTemplate.query( FETCH_BY_ORG_NUMBER_SQL, new Object[]{OPS_NUMBER}, new OrganisationUnitRowMapper() ); log.debug("Fetched {} record(s) from DD_COFACEOPS_TBL by Org Number", results.size()); results.forEach(row -> log.debug("Row: {}", row)); log.debug("End of fetchByOrgNumber"); return results; }catch(Exception e){ e.printStackTrace(); throw e; } } public Map<String, String> fetchAddressDetails(String uuid) { String sql = "SELECT ADR_POSTALADDRESS_STREETNM, ADR_POSTALADDRESS_CITYNAME, " + "ADR_POSTALADDRESS_POSTALCD, ADR_POSTALADDRESS_CNTRYCD " + "FROM DD_COFACEOPS_TBL WHERE OPS_UUID = ?"; return jdbcTemplate.queryForObject(sql, new Object[]{uuid}, (rs, rowNum) -> { Map<String, String> result = new HashMap<>(); result.put("street", rs.getString("ADR_POSTALADDRESS_STREETNM")); result.put("city", rs.getString("ADR_POSTALADDRESS_CITYNAME")); result.put("postalCode", rs.getString("ADR_POSTALADDRESS_POSTALCD")); result.put("country", rs.getString("ADR_POSTALADDRESS_CNTRYCD")); return result; }); } public String fetchOrganisationUnitName(String orgNumber) { String sql = "SELECT OPS_ORGANISATIONUNITNAME FROM DD_COFACEOPS_TBL WHERE OPS_UUID = ?"; List<String> names = jdbcTemplate.query(sql, new Object[]{orgNumber}, (rs, rowNum) -> rs.getString("OPS_ORGANISATIONUNITNAME")); return names.get(0); } } package com.ing.datadist.configreader; import org.springframework.jdbc.core.RowMapper; import java.sql.ResultSet; import java.sql.SQLException; import java.util.HashMap; import java.util.Map; import static com.ing.datadist.api.utils.DataDistributionConstants.LOGICAL_DATA_DOMAIN; import static com.ing.datadist.api.utils.DataDistributionConstants.ORGANISATION_UNIT_NAME_TYPE; //            "SELECT OPS_ORGANISATIONUNITNAME, ORG_NUMBER, ADR_POSTALADDRESS_CNTRYCD, " + //                    "ADR_POSTALADDRESS_STREETNM, ADR_POSTALADDRESS_HOUSENUM, ADR_POSTALADDRESS_HOUSEADD, " + //                    "ADR_POSTALADDRESS_POSTALCD, ADR_POSTALADDRESS_CITYNAME, " + //                    "OPS_EXTID_DATEOFISSUE, OPS_EXTID_EXPIRYDATE, " + //                    "ADR_DIGITALADDR_EMAIL " + //                    "FROM DD_COFACEOPS_TBL WHERE OPS_NUMBER = ?"; public class OrganisationUnitRowMapper implements RowMapper<Map<String, String>> { @Override public Map<String, String> mapRow(ResultSet organisationUnitResultSet, int rowNum) throws SQLException { Map<String, String> row = new HashMap<>(); row.put("organisationUnitName", organisationUnitResultSet.getString("OPS_ORGANISATIONUNITNAME")); row.put("orgNumber", organisationUnitResultSet.getString("OPS_NUMBER")); row.put("countryOfResidence", organisationUnitResultSet.getString("ADR_POSTALADDRESS_CNTRYCD")); row.put("dateOfIssue", organisationUnitResultSet.getString("OPS_EXTID_DATEOFISSUE")); row.put("expiryDate", organisationUnitResultSet.getString("OPS_EXTID_EXPIRYDATE")); row.put("uuid", organisationUnitResultSet.getString("ORG_NUMBER")); row.put("logicalDataDomain", LOGICAL_DATA_DOMAIN); row.put("organisationUnitNameType", ORGANISATION_UNIT_NAME_TYPE); row.put("streetName", organisationUnitResultSet.getString("ADR_POSTALADDRESS_STREETNM")); row.put("houseNumber", organisationUnitResultSet.getString("ADR_POSTALADDRESS_HOUSENUM")); row.put("houseNumberAddition", organisationUnitResultSet.getString("ADR_POSTALADDRESS_HOUSEADD")); row.put("postalCode", organisationUnitResultSet.getString("ADR_POSTALADDRESS_POSTALCD")); row.put("cityName", organisationUnitResultSet.getString("ADR_POSTALADDRESS_CITYNAME")); return row; } }
